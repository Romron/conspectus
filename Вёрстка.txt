###

	Собираю и систематизирую инфу по технологии вёрстки

###






ПРИНЦЫПЫ:
	принцыпы формирования страницы
		HTML - структура страницы
		CSS - внешний вид 
			каждого отдельно взятого элемента
			при возникновении тех или иных событий
		PHP - любые изменения на странице до момента начала её существования
		JS - любые изменения на странице в любое время её существования

	принцып использования обёрток:
		позиционирование и выравнивание:
			крупных блоков
			разных элементов в нутри крупных блоков
		наследование
			многие стили наследуються от родителя то 
			обёртка нужна для разграничения этого влияния



	
Инструменты для вёрстки:
	редакторы кода
		Sublime text безплатный
		VS Code безплатный
		Web storm платный
	браузеры
		для проверки 
		кросс браузерности
	графические редакторы 
		для работы с 
		макетами сайтов
	автоматизация
		автоматизация вёрстки
			css препроцессоры
				SASS
				LESS
		автоматизация сборки проэктов
			grunt 
			gulp
	фреймворки
		bootstrap
		foundation
		materialize
	GIT

Типы вёрстки (реализация описана в файле css.txt)
	Фиксированная
		описание:
			при изменении размеров экрана страница просто маштабируеться
			при этом:
				внешний вид страницы 
					остаёться корректным
					соответствует дизайну макета
	Адаптивый
		описание:
			при достижении размера монитора определённых значений
			дизайн сайта резко меняеться 
				не только размеры но структура и дизайн страницы в целом
		реализация:
			фиксированные размеры элементов в px изменяются медиа запросами
			необходимо стремиться к уменьшению количества медиа запросов
			нормальным считаеться до 5-6 медиа запросов
			медиа запросы должны иметь больший приаритет 
				для этого их необходимо размещать после основного кода

	Отзывчивый (резиновая вёрстка)
		описание:
			плавное изменение размеров при изменении размеров монитора
			при этом:
				внешний вид страницы 
					остаёться корректным
					соответствует дизайну макета
		реализация:
			установить ширину элементов в процентах
				css правило calc()
			убрать минимальную ширину body 
			установить <meta name="viewport" content="width=device-width">

	Смешанный (резиновый адаптив)
		описание:
			гармоничное сочетание адаптива и отзывчивости
		реализация:
			плавное изменение размеров блока до определённых пределов 
			скачёк за счёт медиа запроса 
			и снова плавное изменение до очередного предела

Этапы работы над проэктом
	Анализ макета (PSD или figma)
		шрифты
			определить 
				семейство шрифтов
				начертание
				размер
				алфовит
			подключить
				скачать в папку сайта
		разбивка макета
			выявление повторяющихся элементов
				заголовки
				секции
				карточки
				кнопки
				определить преобладающие стили
					не устанавливать внешнюю геометрию обтикание и т.д.
					исключения выполнять за счёт модификаторов
				сформировать библиотеку блоков
			?! определение сетки
			? преобладающие установки типографики
				семейство шрифта
				размер шрифта
				растояние между строк

			? для препроцесора 
				определение 
					?? базовых переменных
					?? параметры проэкта 
		экспорт данных из макета (нарезка)
	Копирую файловую структуру проэкта
		name_project:
			Source - для исходников
			name_project
				index.html
				css
				js
				img
				fonts
				libs
			info.txt
	Стили
		подключение файлов CSS 
			обнуление CSS
				самым первым подключаемым файлом scc 
				должен быть reset.css (https://gist.github.com/DavidWells/18e73022e723037a50d6)
					т.к. все последующие css правила 
					затирают предидущие
		подключение шрифтов
			скачать в папку fonts
			подключить в css 
				css код  lkzgjlrk.xtybz уже готов:
					https://google-webfonts-helper.herokuapp.com/fonts
		установить модель расчёта размеров блоков
			т.к. 
				в разных браузерах она может отличаться
				блок не должен влиять на окружение

			т.е. толщина границы может 
				увеличивать внешний размерблока 
				или уменьшать внутрений

			html{
				box-sizing: border-box;
			}
			*,*::before,*::after{
				box-sizing: inherit;
			}
		настройки для body 
			нужны для того что бы 
			вложенные элементы наследовали от него
			общие свойства
				пример:
					настройки шрифтов
						цвет
						размер
						прочее
		настройки для картинок
			img {
				max-whith: 100%	
				hight: auto;
			}

Критерии оценки вёрстки
	1. При добавлении или изменении контента 
		вёрстка остаёться корректной
	2. При добавлении илиудалени блоков 
		вёрстка остаёться корректной
	3. Время работы над проэктом
	4. Удобство сопровождения проэкта

МетодологИИ вёрстки
	БЭМ -- блок - элемент - модификатор
		блок 
			ф-ционально независимый компанент страницы, 
			который может быть использован повторно
				отвечает на вопрос "ЧТО?"
			структура имени
				имя-блока
			особенности
				название должно характеризует смысл, а не состояние
				т.е. то что он собой пердставляет
					пример:
						блок "BUTTON" 
						блок "TITLE"
			требования для блоков:
				не должен влиять на своё окружение
					не нежно задавать внешнюю геометрию
						отступы, границы влияющие на размеры или позиционирование
			принцыпы работы с блоками
				блоки можно вкладывать друг в друга
				допустима любая вложеность блоков
				блоки нельзя влаживать в элемент
			популярные названия для блоков:
				подробнее сдесь: https://tpverstak.ru/common-css-class-names/
				page - корневой элемент страницы
				body
				header
				footer
				section
				content - содержимое элемента
				sidebar
				aside - блок с дополнительной информацией
				widget
				обёртки: 
					wraper или wrap - внешняя обёртка
					inner - внутреняя обёртка
				контейнеры:
					блочные
						container
						holder
						box
					Строчные
						row
					Столбцы
						column
						col
				grid - раскладка
				кнопки
					button
					btn
				control - елементы управления
				dropdown - выпадающий список
		элемент 
			составная часть блока
			неможет использоваться без блока
				отвечает на вопрос "ЧТО?"
			особенности
				название должно характеризует смысл, а не состояние
				т.е. то что он собой пердставляет
			структура имени
				имя-блока__имя-элемента
			принцыпы работы с элемемнтами
				элемент это всегда часть блока 
				и не должен использоваться отдельно от блока
					а не другого элемента
						пример:
							так нельзя:
								block__elem1__elem2 
				элементы можно вкладывать друг в друга
				допустима любая вложенность элементов
				элемент не обязательный компанент блока
		модификатор
			сущность определяющая 
				внешний вид, состояние или повидение компанента
				отвечает на вопрос "КАКОЙ?"	
			структура имени
				имя-блока_модификатор
				имя-блока__имя-элемента_модификатор
			особенности
				название характеризует 
					внешний вид 
					состояние
					поведение
			имя модификатора отделяется от имени компанента 
			одним подчёркиванием или дефисом
	AMCSS
	OOCSS
	Atomic CSS
	OPOR
	MCSS
	SMACSS
	FUN
	DoCSSa

Необходимые технологии:
	Автоматизация вёрстки
		описание:
			препроцессор
				на языке препроцессора пишутся стили
				преобразовываються в css 
			постпроццессор
				оптимизирует и улучшает css
		Препроцессоры
			Описание:
				используют язык прогромирования который в последствии превращаеться в CSS 
				Функционал общий для всех препроцессоров:
					Вложенность
					Импорт кода
						вместо одного большого файла множество мелких
						препроцессор просто вставляет код из многих мелких файлов в один общий
					Ф-ции для работы с цветом
					Переменные
					Примеси (миксины) и наследование
			SASS
				синтаксис
					Sass
						нет фигуных скобок
							их роль выполняет табуляция
						нет точки с запятой в конце строк
						? селекторы пишуться иначе
					SCSS 
						фигурные скобки и точки с запятой как и в CSS 
				вложености правил
					описание
						правила для дочерних элементов пишуться в нутри  блока родительских правил
							пример:
								sass
									.wrap-main p
										......
										.mrap
											......
								scss
									.wrap-main p{
										......
										.mrap{
											......									
										}
									}
								css
									wrap-main p{
										....
									}
									wrap-main p .mrap{
										....
									}
					?операторы для написания селектров
						<
						>
						привязка к родительскому селектору(!!):
							& - обозначает радителя
								!!! не радителя в HTML а радителя в стилях
								пример:
									HTML
										<div class="block">
											<div class="link">
											
											</div>						
										</div>
									SASS
										.link {
											.block & {

											}
										}
									CSS
										.block .link{

										}
				вложености свойств
					описание
						любые css свойства которые пишуться через дефис 
						могут быть записаны ка квложенный блок
						пример
							sass
								.wrap
									margin:
										top: 10px
										bootom: 5px
										left: 15px
										right: 80px
							css
								.wrap{
									margin-top: 10px
									margin-bootom: 5px
									margin-left: 15px
									margin-right: 80px	
									}							
				дериктивы и правила
					@import
						описание  
							просто вставляет в Sass файл код из указанного файла в место этой строчки:
								@import "file.scss";
						синтаксис
							ипортировать можно Sass, Scss, css файлы
							дириктива @import сработает 
								как в обычном css файле в том случа если
									указано расширение css
										пример
											Sass
												@import "file.css"
											css
												@import url(file.scss);
									в пути присутствуют медиа параметры или медиа запросы
										пример
											Sass
												@import "foo" screen
											css
												@import "foo" screen;
									в пути присутствуют "http"
										пример
											Sass
												@import "http://foo.com"
											css
												@import "http://foo.com";	
									в пути присутствуют url()
										пример
											Sass
												@import url(foo)
											css
												@import url(foo);	
								для импорта в Sass файл 
									указано расширение .sass, .sccs, ,tp расширения для css файлов
										пример
											@import "file.sass"
											@import "file.sccs"
											@import "file"
								фрагменты
									файлы названия которых начинаются с подчёркивание
									при импорте не требуют указания подчёркивания или расширения
										пример
											_file.sass
											Sass
												@import "file"
					@at-root
						подымает содержащиеся в ней правила в корень отменяя цепочку от родителя
							пример
								Sass
									.selector
										......
										@at-root
											.item
												......
								CSS
									.selector{
										.......
									}
									.item{
										.......
									}
					выражения
						@if() @else
						@for 1 to 11
						@aech
							перебор списка значений
								пример
									Sass
										@aech $name in carousel, block, vertical, reviews, footer
											.section #{$name}
												background-image: url(img/#{$name}.jpg)
									SCC
										.section-carousel{
											background-image: url(img/carousel.jpg)
										}
										.section-block{
											background-image: url(img/block.jpg)
										}
										.section-vertical{
											background-image: url(img/vertical.jpg)
										}
										.section-reviews{
											background-image: url(img/reviews.jpg)
										}
										.section-footer{
											background-image: url(img/footer.jpg)

										}
						@while
				шаблоны
					описание
						разные элементы используют одинаковый набор css правил
					размещение
						по ближе к началу файла 
						для того что бы в результирующем css файле 
						при необходимости его можна было бы переопределить
					создать шаблон
						%name_tpl{
							....
						}
						или создать клас не существующий в html
					использовать шаблон
						@extend %name_tpl;
				миксины
					создание:	
						@mixin name_mixin($color){
							border: $color 1px solid;
						}
					использование:
						include name_mixin($color);
				SassScpipt
					описание
						предназначеен для автоматической генирации стилей
						селекторов и свойсв
					переменные
						$var:значение;				
					операции с числами и строками
						математические операторы
							выполняет матиматические операции непосредственно в правиле
								пример: 
									в scss:
										width: 300px / 960px * 100%;
									в css :
										width: 31,25%;
						конкатенация строк  плюсом 
						интерполяция
							получение нового значения используя другие значения  
							чаще всего используется
								получения значения переменной интегрируя значения других переменных
								возможна генирация
									селекторов
									названий свойств
									значений свойст
							пример:
								Sass
									.selector
										$cn: content
										#{$cn}: "con" + "tent"

									$in: интер
									.interpol
										content:"#{$in}поляция"
								css
									.selector{
										content: content
									}

									.interpol{
										content: интерполяция;
									}
					операции с цветами
						все арифметические операции выполняются для каждого цвета отдельно
							пример
								Sass
									$color1: #440203 + #550506
									$color1 == 990709
						в формате rgba(r,g,b,a) прозрачности операндов должны совпадать 
							пример
								$color1:$color3: rgba(145,15,35,0.75) + rgba(20,45,170,0.75)

				коментирование
					/* комментарий попадёт в css файл */
					// комментарий не попадёт в css файл 

			Сборщики
				Prepros
		Постпроцессоры
			Описание:
				оптимизируют CSS 
			PostCSS
	Gulp
		описание
			менеджер-задач для автоматизации выполнения рутинных операций
			написанный на языке программирования JavaScript
			использует командную строку для запуска задач, определённых в файле Gulpfile
			наиболее частые задачи
				взять какойто файл
				передать его обработчику
				результат обработки положить по указаному пути
					пример
						file.sass в file.css
		установка
			установить nod-js
			установить gulp глобально 
				в командной строке:
					npm i gulp -g
				!!! в пути к проэкту не должно быть кирилицы !!!
		установка пакетов (они же плагины, модули) в проэкт
			gulp
				npm i gulp --save-dev
					в папке проэкта появиться папка node_modules
					в которой
						установленный пакет gulp
						все зависимости
						будут устанавливаться добавляемые пакеты
			sass
				установка
					npm i gulp-sass --save-dev
				минификация sass файлов
					cssnano и rename
						npm i gulp-cssnano gulp-rename --save-dev
			JS
				установка
					bower - установщик библиотек js
						установка
							неодходимо установить в систему GIT
							устанавливается обязательно глобально
							npm i g bower
						использование
							в корне проэкта создать файл .bowerrc
								виндовс такие файлы не создаёт
									нужно через filezile
							в файле указать путь для установки пакетов
								{
									"directo": "app/libs/"
								}
							в командной строке в папке проэкта:
								bower i <project_name> 
									пример
										bower i jquery
				сборка и минификация js файлов 
					concat и uglifyjs
						установка
							nmp i gulp-concat gulp-uglifyjs --save-dev
			browser-sync
				npm i browser-sync --save-dev
			del
				npm i del --save-dev
			imagemin и imagemin-pngquant
				npm i gulp-imagemin imagemin-pngquant --save-dev
			cache
				npm i gulp-cache --save-dev
			автопрефиксер
				описание
					добавляет префиксы к css свойствам для 
					обеспечения максимальной совместимости с браузерами
				npm i gulp-autoprefixer --save-dev
		подключение пакетов (они же плагины, модули)
			gulp
				var gulp = require('gulp');
			sas
				var sass = require('gulp-sass'); 
			browser-sync
				var browser = require('browser-sync'); 			
			concat и uglifyjs
				var concat = require('gulp-concat'), 
					 uglifyjs = require('gulp-uglifyjs'); 
			cssnano и rename
				var cssnano = require('gulp-cssnano'), 
					 rename = require('gulp-rename'); 
			del
				var del = require('del'); 
			imagemin и imagemin-pngquant
				var imagemin = require('gulp-imagemin');
				var pngquant = require('imagemin-pngquant');
			cache
				var cache = require('gulp-cache');
			autoprefixer
				var autoprefixer = require('gulp-autoprefixer');
		алгоритм оброботки проэкта (?)
			компиляция sass файлов 
			сборка и минификация js файлов 
			синхронизация с браузером
			отслеживане изменений в файлах проэкта		
		работа с проэктом
			инициализация
				в командной строке 
					из папки проэкта
						npm init
						ответить на вопросы
				в папке проэкта должен появится файл
					packeg.json
						это манифест проэкта
			структура проэкта
				myproject
					app папка в которой будет разрабатываться проэкт
						css
						fonts
						img
						js
						sass
						index.html
					dist папка для уже обработанного проэкта готового для передачи клиенту
					gulpfile.js
						основной фай в котором прописываются подключённые покеты
						создаються задачи
		работа с задачами
			создание задач
				описание
					обычная ф-ции на языке JS 
						допускаеться перенос методов на новую строку
						пример
							gulp.task('my_task_1', funktion(){
									return gulp.src('some_file')
										.pipe(plugin())	// какие то операции с файлом
										.pipe(gulp.dest('path_result_file'))
									});	 
			наиболее распространённые задачи
				запуск компеляции sass файлов 
					gulp.task('sass', funktion(){
							return gulp.src('app/sass/**/*.sass')
								.pipe(sass())
								.pipe(autoprefixer(['last 15 versions','> 1%','ie 8','ie 7'],{cascade: true}))
								.pipe(gulp.dest('app/css'))
								.pipe(browserSync.reload({stream: true}))
							});	
				сборка и минификация css файлов
					gulp.task('css-libs',['sass']funktion(){
							return gulp.src('app/css/libs.css')
								.pipe(cssnano())
								.pipe(rename({suffix:'.min'}))
								.pipe(gulp.dest('app/css'))
							});				
				сборка и минификация js файлов
					gulp.task('scripts', funktion(){
							return gulp.src('app/libs/jquery/dist/jquery.min.js')
								.pipe(concat('libs.min.js'))
								.pipe(uglifyjs())
								.pipe(gulp.dest('app/js'))
							});
				оптимизация и кеширование изображений
					gulp.task('img', funktion(){
							return gulp.src('app/img/**/*')
								.pipe(cache(imagemin({
									interlaced: true,
									progresive: true,
									svgPlugins: [removeViewBox: false],
									une:[pngquant()]
								})))
								.pipe(gulp.dest('dist/img'));
						});													
				синхранизация браузера
					gulp.task('browser-sync', funktion(){
							browser-sync({
								server:{baseDir:'app'},
								notify:false
							});
						});
				отслеживания изменений в файлах
					gulp.task('watch',['browser-sync','css-libs',scripts] funktion(){
								gulp.watch('app/sass/**/*.sass', ['sass'])
								gulp.watch('app/**/*.html', browserSync.reload)
								gulp.watch('app/**/*.js', browserSync.reload)
						});
				очистка продакшина перед сборкой
					gulp.task('clean', funktion(){
							return cache.clearAll();
						});
				очистка кеша
					описание
						выполняеться вручную 
							после изменения связаных папок
							при всяких недоразумениях
					gulp.task('clean_cash', funktion(){
							return del.sync('dist')
						});				
				сборка продакшина
					gulp.task('biuld',['clean','img','sass','scripts'],funktion(){
							gulp.src(['app/css/main.css',
										'app/css/libs.min.css'])
								.pipe(gulp.dest('dist/css'));
							gulp.src('app/fons/**/*')
								.pipe(gulp.dest('dist/fonts'));
							gulp.src('app/js/**/*')
								.pipe(gulp.dest('dist/js'));
							gulp.src('app/*.html')
								.pipe(gulp.dest('dist'));
						});					




			запуск задач
				в файле gulpfile.js
				в консоли: gulp my_task_1
			остановка выполнения задач
				'ctrl+c' дважды
		шаблоны выборки файлов glob   
			подробнее
				https://hgbook.bacher09.org/html/file-names-and-pattern-matching.html#idp34547472


	Структурирование элементов на странице
		GRID 
		FLEX
		Bootstrap 



 