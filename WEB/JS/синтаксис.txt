Источники:
   https://youtu.be/Ti2Q4sQkNdU

Термины:

Смежные области:



----------------------- ТЕОРИЯ start -----------------------  
   ECMAScript 5
      переменные 
         var .....
            видима во всех блоках 
            существует в коде до момента её объявления
               пример 1:
                  b = 20; 
                  console.log(b);   // в консоль 20 
                  var b = 10;
               пример 2:  
                  console.log(b);   // в консоль ERROR
                  var b = 10;
      функции
         function(){}
            создаёт свой контекст вызова
            переопределить контекст:
               function(){
                  const self = this;
                  setTimeout(function(){
                     console.log(self)
                     },500)
               }
         параметры по умолчанию
            function(a,b,c){
               a = typeof a !== 'undefined' ? a : 42;
               b = typeof b !== 'undefined' ? b : 'default_b';
               с = с || 'defaul c'
            }
         псевдо(!) массив
            содержит все параметры переданные в фукуцию
      строки
         записываются в кавычках
         все кавычки равноправные
         щабдоны строк 
            конкатинация " строка " + b + " строка ";
   ECMAScript 6  релиз 2015 года
      переменные
         let .....
            видима только в том блоке в котором обьявлена
            несуществует в коде до момента её объявления
               пример 1: 
                  console.log(b);   // в консоль ERROR 
                  let b = 10;
               пример 2: 
                  b = 20;
                  console.log(b);   // в консоль ERROR
                  let b = 10;  
               НО!!! пример 3
                  functiom func(){
                     b = 20;
                  }
                  let b;
                  func();
                  console.log(b);   // в консоль 20

            переменная с таким же именем объявленная вне блока будет существовать независимо
      константы  
         const .....
            всё тоже что и для let 
            нельзя переназначить НО можно изменить внутренее содержание есле это объект или массив
               пример 1:
                  cons b = 20;
                  b = 10;  // в консоль ERROR
               НО  пример 2: 
                  const b = [1,2,3,4];
                  b = 'str';     // в консоль ERROR
                  b.push(7);
                  console.log(b);   // в консоль [1,2,3,4,7]
      фукуции
         стрелочные функции они же лямда фукуции
            не создаёт свой контекст вызова а указывает на верхний контекст по стеку вызова
               пример  
               function(){
                  setTimeout(() => {
                     console.log(this)
                     },500)
               }
            const b = (a,b)=>{ return a + b }  // общий синтаксис
            const b = a =>{ return a ** 3 }  // если параметр один
            const b = a => return a ** 3  // если строчка одна
         параметры по умолчанию
            function(a=3,b=5){}
         Rest 
            function func(a, b, ...args){}      // массив args будет содержать любое колличество аргументов после двух первых
         Spred
            разворачивает переданный массив в строку
               let arr_1 = [1,2,3,4,5];
               console.log(...arr_1);      // в консоль  строка: 1 2 3 4 5
               const arr_2[9,9,7, ...arr_1]
                console.log(arr_2);      // в консоль  массв: [9, 9, 7, 1, 2, 3, 4, 5]
      строки
         записываются в кавычках
         одинарные и двойные кавычки равноправные
         обратвые кавычки 
            шаблоны строк
               в конструкции ${} может находиться всё что угодно переменные, вызовы функций, объекты, выражения
               let b = 20;
               console.log(`стрка ${b}`);   // в консоль: строка 20
            могут включать в себя любые другие кавычки
            сохраняют пробелы и переносы строк
            методы строк
               str.starstWith('что то');  // поиск подстроки в начале строки
               str.endsWith('что то'); // поиск подстроки в конце строки
               str.includes('что то');  // поиск подстроки
               str.repeat(5);   // дублирование строки указанное количество раз
               str.trim();    // удалить пробелы
      реструкторизация
         let arr_1 = [1,2,3,4,5];
         ES5:
            let a = arr_1[0];
            let b = arr_1[1];
         ES6:
            let [a,b, ...c] = arr_1;
         console.log(a, b);      // в обоих случаях в консоль  1 2 [3,4,5]
         значение по умолчанию
            let arr_1 = [1,undefined,3,4,5];
            let [a,b=70, ...c] = arr_1;
            console.log(a, b);      // в обоих случаях в консоль  1 70 [3,4,5]
         пропуск значения
            let arr_1 = [1,2,3,4,5];
            let [a,,c, ...d] = arr_1;
            console.log(a, c, d);      // в обоих случаях в консоль  1 3 [4,5]         
         
         в объёктах всё тоже самое но при передачи ф-ции кантекст нужно передавать в ручную
            const address = {
               country: 'Ukrain',
               city: 'Kiev',
               street: 'Tamma',
               concat: function() {
                     return `${this.country}, ${this.city}, ${this.street}`
                  }
            }
            const {city, country, street, concat: addressConcat} = address
            console.log(сoncat.call(address))      // кантекст передан в ручную
         создать новый объект изменив и добавив некоторые поля
            const newAddress = {...address, street: 'Gogoly', code: 123}
            console.log(newAddress)
            // console.log(address.concat())
      модули   файлы -> отдельные модули !!!       https://learn.javascript.ru/modules-intro
         в браузере также существует независимая область видимости для каждого скрипта <script type="module">
            необходимо явно сказать браузеру, что скрипт является модулем, при помощи атрибута <script type="module">
               <!doctype html>
               <script type="module">
                  import {sayHi} from './say.js';
                  document.body.innerHTML = sayHi('John');
               </script>
            если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window, тогда получить значение переменной можно обратившись к window.user
         модули не работают локально. Только через HTTP(s)
            через протокол file://  директивы import/export не работают
         в модуле на верхнем уровне this не определён (undefined).
         в модулях всегда используется режим use strict
         модуль имеет свою собственную область видимости
         для того что бы переменные (функции и т.д) были видимы в других файлах
            export let b = 1;
            import { b, funck } from 'путь к модулю'; 
            import * as my_import from 'путь к модулю';
         экспорт по дефолту
            export default {
               function func(){}
            }
            import my_def_import, { b, funck } from 'путь к модулю';    // не привязано к имени области  export default (!!??)
               my_def_import.func();
      классы      устроены на основании прототипов  __proto__ 
         создать класс
            class MyClass {
                  construktor(param_1){
                  this.param_1 = param_1;
               }
               field_1 = 'значение поля 1';
               metod_1(){
               }
            }
            const instance = new MyClass(param_1);
            instance.metod_1();
            console.log(instance.field_1);
         наследоваие
            class MySecondClass extends {
                  construktor(param_1, param_2){
                     super(param_1)    // передать параметр в клас родитель
                     this.param_2 = param_2;    
                  }
               field_1 = 'значение поля 1';  // переопределить поле класса родителя
               metod_1(){        // переопределить метод класса родителя
                  super.metod_1();     // обращение к методу родителя
                  .... code .....
               }
            }  
         статические методы и поля        ???????????????
            statick metod_3(){}
         динамические ключи
            class MyClass {
                  construktor(param_1){
                  this.param_1 = param_1;
               }
               [dinam_key] : 'что то';
               field_1 = 'значение поля 1';
               metod_1(){
               }
            }            
         гетеры и сетеры 
      символы
         тип данных который появился в ES6 
         задаёт уникальные ключи (значения)
      генерация ошибок
         throw new Error('текст ошибки');
         try{
            .... что то ....
         }catch(e){
            console.log(e);
         }
      генераторы и итераторы
      цыкл for (  of)  - перебирает элементы сущности
      промисы и массивы промисов
      async await
      set и map
      reflect 
      proxy
      import -- export
         вариант 1 в index.html
            перечислить в строгом порядке все файлы из которых прописывается импорт
               <script src="../build/js/script_1.js"></script>
               <script src="../build/js/script_2.js"></script>
               <script src="../build/js/main.js"></script>
            import - export не нужен
         вариант 2 import - export
            принято, не обязательно(!!) import в начале файла
            для нативного js расширение необходимо(!) при зборке webpack расширение можно опустить
            index.html подключать только файл в котором прописан импорт обязательно указать type="module"
               <script type="module" src="../build/js/main.js"></script>      
            export default -- экспорт по умолчанию
               эксрортировать по умолчанию можно только один блок из обного файла
                  import псевдоним(!!)_того_что_импортируется from 'путь_откуда_импорт.js' 
            import - export
               каждая ф-ция или класс в файле экспортируется отдельно
                  export funktion fun_1(){}
                  export funktion fun_2(){}
                  export default  funktion fun_3(){}
                  тогда:
                     import fun_3, {имя(!)_того_что_импортируется_1, имя(!)_того_что_импортируется_2} from 'путь_откуда_импорт.js'
                  или с псевдонимами:
                     import alias_fun_3, {имя(!)_того_что_импортируется_1 as alias__того_что_импортируется_1, имя(!)_того_что_импортируется_2 as alias__того_что_импортируется_2} from 'путь_откуда_импорт.js'
                  или всего под одним псевдонимом
                     import * as alias_main from 'путь_откуда_импорт.js'

                     alias_main.имя(!)_того_что_импортируется_1;
                     alias_main.имя(!)_того_что_импортируется_2;

               методы и поля класса могут эксрортироваться отдельно от класса
                  let myClass = {
                     fild_1 : "",
                     fild_2 : 23,
                     method_1 : function(){
                        ....  .... ....
                     },
                     method_2 : function(){
                           ....  .... ....
                        },
                  }
                  export const alias_fild_1 = myClass.fild_1;
                  export const alias_method_2 = myClass.method_2;

               динамический импорт
                  import('путь_путь_откуда_импорт')   // возвращает промис
                  import('путь_путь_откуда_импорт').then((имя(!)_того_что_импортируется)=>console.log(имя(!)_того_что_импортируется) )
               реекспорт 
                  один файл как точка входа 
                     export fun_3, {имя(!)_того_что_импортируется_1, имя(!)_того_что_импортируется_2} from 'путь_откуда_импорт.js'


----------------------- ТЕОРИЯ end ------------------------- 


----------------------- Практика start ---------------------

----------------------- Практика end -----------------------



----------------------- Проблемы -- решения start ---------

----------------------- Проблемы -- решения end -----------








----------------------- ЧЕРНОВИК -----------------------




