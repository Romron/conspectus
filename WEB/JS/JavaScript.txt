Источники:
	https://www.youtube.com/@TimurShemsedinov       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	https://github.com/HowProgrammingWorks/Index		Базовый курс инженерии программного обеспечения 

	https://codepen.io/     всё готовое!!!
	https://learn.javascript.ru/	!!!!!
	https://youtu.be/4AETFuOaq3s			Топ-12 фишек программирования на JavaScript с массивами. Ты просто обязан их знать!
	https://youtu.be/csuTmwTKWjc			Оптимизируем код
	https://youtu.be/VhKUYqr7P1Q			События мыши
	https://youtu.be/kizGhzeNE64			!!! Замыкание приватные методы наследование
	https://youtu.be/mI6Jcfsgma4?si=lvacvlnmipebHxdK		!!! лексическое окружение и замыкание
	https://youtu.be/07FllcTRj84?si=nVbqdAiEvgeUFgpY		!!! var, let, const
	https://youtu.be/aFxQvCqrUC0?si=4ehj_Ro6WMamjmkj		!!! this



Термины:

Смежные области:


----------------------- TO USE  -----------------------

WebGL (Web Graphics Library) - программная библиотека для языка JavaScript предназначенная для визуализации интерактивной трёхмерной графики


Метод для рекурсивного перебора полей объекта в которых находятся массивы с перебором самих массивов
	   objClearForTask(obj) { 		


			function modifyArray(array) {
				return array.map(item => item.replace(this.src.php, this.prod.php));
			}
			let bound_ModifyArray = modifyArray.bind(this);		// привязка контекста к родительскому объекту 

			function processObject(obj) {
				return Object.fromEntries(
					Object.entries(obj).map(([key, value]) => {
						if (Array.isArray(value) && value.length !== 0) {
							return [key, bound_ModifyArray(value)];
						}
						if (typeof value === 'object' && value !== null) {
							return [key, processObject(value)];
						}
						return [key, value];
					})
				);
			}
			return processObject(obj);
   },


------------------------------------------------------- 




ПРОМИСЫ			https://habr.com/ru/company/vk/blog/269465/

ОБЪЕКТЫ
	объекты – это ассоциативные массивы с рядом дополнительных возможностей

	создание объектов
		let user = new Object(); // синтаксис "конструктор объекта"
		let user = {};  // синтаксис "литерал объекта"
	добавление свойств
		присоздании:
			let user = {     // объект
				name: "John",  // под ключом "name" хранится значение "John"
				age: 30        // под ключом "age" хранится значение 30
			};
		после создания:
			user.isAdmin = true;
	удаление свойства: delete obj.prop.
	проверка существования свойства: спомощью оператора "in": "key" in obj.
	перебор свойств объекта: цикл for: for(let key in obj)
	доступ к свойствам
		если имя свойства не содержит пробелов то через точку obj.property
		если имя свойства содержит пробелы или спец символы  то 
			с помощью квадратных скобок 
			при этом имя заключаеться в кавычки	obj["property"]
		если в квадратных скобках имя без кавычект то
			это оно воспринимаеться как переменная содержащая имя свойства
		если в квадратных скобках выражение то 
			именем свойства будет результат его вычесления
	Именование свойств
		ограничений к именам свойств нет
			они могут быть 
				строками
				символами(?)
		другие типы будут преобразованы к строкам
		имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:

	Свойства бъекта, объявленного через const, могут быть изменены

ФУНКЦИИ			https://youtu.be/nGVYdna4kq4?si=ki54Ial1w7oFAHZ7
	JavaScript функции – это значения!!! представляющее «действие»
	Обычные значения, такие как строки или числа представляют собой данные
	
	Способы объявления ф-ций
		декларативное объявление функции
			всё стандартно как и вов сех других языках
		функциональное выражение
			let x = function() {
						  alert( "Привет" );
						};	// точка с запятой обязательны! т.к. это не блок кода а выражение с присваиванием
		разница в этих способах заключаеться в том что
			при декларативном объявление функция доступна до её объявления 
				т.к. движок при рендеренге кода первым делом 
				ищет в нём Function Declaration и создаёт все такие функции
			при функциональном выражении функция доступна только после её объявления
				т.к. движок при рендеренге кода онейничего не знает
				и узнает только когда доберёться до её объявления в процесе выполнения кода
		функция видима только внутри блока кода, в котором объявляется
			для того что бы онабыла видима вне блока её нужно присвоить наружной переменной 
			это можно сделать после либо во время объявления с помощью ф-ционального выражения
		суть заключаеться в том что любой синтаксис это 
			всеголиш способ сохранить код ф-ции в переменную таким образом что
				console.log(x); // выведет код(!!!) ф-ции
				console.log(x()); // выведет результат работы ф-ции
		вызов ф-ции на исполнение от вида синтаксиса её объявления не зависит.
	Функции-«колбэки»
		это обычные ф-ции которые передаються в другую ф-ции в виде аргументов
		могут быть объявлеными в при вызове самой функции при этом имена им не нужны 
		по этому они называються анонимными:
			let a = myFunction(d,j,
							function_1(){
								// какойто код
							},							
							function_2(){
								// какойто код
							})
		анонимные ф-ци недоступны вне ф-ции в которой объявлены
	Ф-ции-стрелки

МАССИВЫ
	Методы массивов
		Добавление/удаление элементов
			arr.push(...items) – добавляет элементы в конец
			arr.pop() – извлекает элемент из конца
			arr.shift() – извлекает элемент из начала
			arr.unshift(...items) – добавляет элементы в начало
			arr.splice(str) – Умеет всё: добавлять, удалять и заменять элементы.
			arr.splice(index[, deleteCount, elem1, ..., elemN])
			arr.slice([start], [end]) возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end)
			arr.concat(arg1, arg2...) создаёт новый массив, в который копирует данные из других массивов и дополнительные значения

		Массив перебирающие методы
			каждый метод автоматически передаёт в colback функцию три параметра
				colbackFunction(element, index, array)
			эти методы не изменяют исходный массив
			forEach() выполняет указанную функцию один раз для каждого элемента в массиве
				нечего не возвращает!!
				arr.forEach(function callback(currentValue, index, array) {
					//your iterator
				}[, thisArg]);
			Array.prototype.map()	передаёт в colback функцию каждый элемент массива 
				возвращает новый массив с результатом вызова указанной функции для каждого элемента массива
			Array.prototype.filter()	создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции
				т.е. colback функция должна(!!) вернуть folse или true 
			Array.prototype.every()		проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции
			Array.prototype.some()		проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции
			Array.prototype.reduce()	применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение
				colback функция выполняющаяся для каждого элемента массива, принимает четыре аргумента:
					currentValue текущий обрабатываемый элемент массива
					index текущего обрабатываемого элемента массива. Необязательный
					array, для которого была вызвана функция reduce. Необязательный
					initialValue Объект, используемый в качестве первого аргумента при первом вызове функции callback. Необязательный
			Array.prototype.reduceRight() всё тоже самое что и reduce() только справа-налево


		Поиск в массиве
			indexOf() возвращает первый индекс, по которому данный элемент может быть найден в массиве или -1, если такого индекса нет
				arr.indexOf(searchElement[, fromIndex = 0])

Оператор объединения с null " ?? "
	Предназначен для выбора из списка переменых той значение которой определено.
	аналогичен || за тем исключением что:
		|| возвращает первое истинное значение.
		?? возвращает первое определённое значение.
	Пример:
		результатом выполнения этого кода  a ?? b  будет:
			а если a != null или undefined  (0 != undefined)!!!!!
			b если a = null или undefined  

"Масив масивов"  преобразовать в объект
	Источник: 1:10:50  https://youtu.be/7FbAM52h9QA?si=Wy5-pxWRwLV4aXWI
		arr_arrs.reduce((acc,[key,value]) => ({
			...acc,
			[key.trim()]:value
		},{}))


Отправка форм
	FETCH
		regForm.addEventListener('submit', function (event) {
			event.preventDefault();

			const formData = new FormData(regForm);			// собирает все данные из формы в т.ч. значение параметров action и method и
			const data = Object.fromEntries(formData.entries());		// преобразует данные в пару "ключ-значение" в объекте

			fetch(regForm.action, {
				method: regForm.method,
				headers: {
							'Content-Type': 'application/json',		// указывает формат данных 
								// т.е. простая json строка при этом php НЕ заполняет данными массив $_POST - он остаётся ПУСТЫМ!
								// если Content-Type: application/x-www-form-urlencoded или multipart/form-data - php заполняет данными массив $_POST
							},
							body: JSON.stringify(data),	// преобразует данные в json строку для 'Content-Type' : 'application/json'
							// body: new URLSearchParams(data).toString()  // для 'Content-Type' : 'application/x-www-form-urlencoded' или 'multipart/form-data'
							// URLSearchParams: Этот объект используется для создания строки запроса, которая соответствует формату application/x-www-form-urlencoded
							// toString(): Преобразует объект URLSearchParams в строку формата key1=value1&key2=value2, что PHP понимает как данные формы.
						})
						.then(response => {
							if (response.ok) {
								return response.json();
							} else {
								throw new Error('Ошибка при отправке формы');
							}
							})
						.then(data => {
						console.log('Успех:', data);
					})
				.catch(error => {
					console.error('Ошибка:', error);
			});
		});


	Выбор формата данных для отправки:
		application/x-www-form-urlencoded
			Это стандартный формат для отправки данных через формы HTML по умолчанию. 
			Данные кодируются в виде строки, где каждый параметр и его значение разделяются амперсандом (&), 
			а пары ключ-значение разделяются знаком равенства (=).
				пример:	login=user1&email=user1%40example.com&password=secret
			Когда использовать:
				для отправки простых текстовых данных, таких как строки, числа, и небольшие массивы.
				если нужно обеспечить максимальную совместимость с сервером, который ожидает данные формы (как в $_POST в PHP) 
				т.к. они автоматически попадают в массив $_POST в PHP.

		multipart/form-data
			Этот формат используется, когда форма включает файлы (например, input type="file"). 
			Данные разделяются границами и отправляются в виде множества частей, каждая из которых содержит один файл или поле формы.
				Пример:
					--boundary
						Content-Disposition: form-data; name="login"
					user1
					--boundary
						Content-Disposition: form-data; name="file"; filename="example.txt"
						Content-Type: text/plain
					(file content here)
					--boundary--

			Когда использовать:
				Отправка файлов: Если вы отправляете файлы наряду с другими данными.
				Сложные формы: Когда данные формы содержат бинарные данные или большие объемы данных.
				Требования сервера: Если сервер ожидает файл, который должен быть загружен с другими данными формы.