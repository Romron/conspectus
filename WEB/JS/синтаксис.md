Источники:
   https://youtu.be/Ti2Q4sQkNdU
   https://developer.wordpress.org/block-editor/how-to-guides/javascript/esnext-js/
   9 JavaScript приёмов Must Have для junior    https://youtu.be/9Ek1mzIJzME


   https://www.youtube.com/@TimurShemsedinov       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Термины:

Смежные области:



----------------------- ТЕОРИЯ start -----------------------  
   ECMAScript 5
      переменные 
         var .....
            видима во всех блоках 
            существует в коде до момента её объявления
               пример 1:
                  b = 20; 
                  console.log(b);   // в консоль 20 
                  var b = 10;
               пример 2:  
                  console.log(b);   // в консоль ERROR
                  var b = 10;
      функции
         function(){}
            создаёт свой контекст вызова
            переопределить контекст:
               function(){
                  const self = this;
                  setTimeout(function(){
                     console.log(self)
                     },500)
               }
         параметры по умолчанию
            function(a,b,c){
               a = typeof a !== 'undefined' ? a : 42;
               b = typeof b !== 'undefined' ? b : 'default_b';
               с = с || 'defaul c'
            }
         псевдо(!) массив
            содержит все параметры переданные в фукуцию
      строки
         записываются в кавычках
         все кавычки равноправные
         щабдоны строк 
            конкатинация " строка " + b + " строка ";
   ECMAScript 6  релиз 2015 года
      переменные
         let .....
            видима только в том блоке в котором обьявлена
            несуществует в коде до момента её объявления
               пример 1: 
                  console.log(b);   // в консоль ERROR 
                  let b = 10;
               пример 2: 
                  b = 20;
                  console.log(b);   // в консоль ERROR
                  let b = 10;  
               НО!!! пример 3
                  functiom func(){
                     b = 20;
                  }
                  let b;
                  func();
                  console.log(b);   // в консоль 20

            переменная с таким же именем объявленная вне блока будет существовать независимо
      константы  
         const .....
            всё тоже что и для let 
            нельзя переназначить НО можно изменить внутренее содержание есле это объект или массив
               пример 1:
                  cons b = 20;
                  b = 10;  // в консоль ERROR
               НО  пример 2: 
                  const b = [1,2,3,4];
                  b = 'str';     // в консоль ERROR
                  b.push(7);
                  console.log(b);   // в консоль [1,2,3,4,7]
      фукуции
         ф-ции мажно возвращать из ф-ций так же как и другие переменные
         само вызывающаяся ф-ция  ( IIFE )      !! https://www.codehint.ru/articles/2014-07-27_javascript-self-invoking-functions    https://learn.javascript.ru/closure#iife    
            преимущество от использования самовызывающихся функций вы получите, 
               если нужно выполнить код один раз и 
               сохранить его резульататы во "внешней среде" (без объявления глобальных переменных).
         лексическая область видимости          https://ru.hexlet.io/courses/introduction_to_programming/lessons/env/theory_unit
            область видимости компонента определяется местом расположения объявления этого кампонента в коде
            т.е. вложенные блоки имеют (могут изменять) к внешним областям видимости
               внешние блоки не имеют доступа  (не могут изменять) к внутереним областям видимости
         лексическое окружение
            это хранилище для данных в памяти и механизм для извлечения этих данных при обращении.
                 интерпретатор создаёт специальный словарь -- лексическое окружение (LexicalEnvironment)
               когда вызывается функция,     
                 и привязывает этот словарь к этому вызову т.е. СОЗДАЁТ КОНТЕКСТ!!  
                  все определения констант, переменных, ф-ций и прочего внутри функции автоматически записываются в этот словарь. 
                     имя определения (идентификатор, то есть имя константы, переменной и так далее) 
                     становится ключом, а значение определения становится значением в словаре. 
                  К таким определениям относятся аргументы, константы, функции, переменные и т.д. 
                  !!!   наполнение словаря происходит при вызове функции, а не при определении  !!!
               В процессе выполнения функции значения переменных могут меняться, 
                  что сразу же отражается в лексическом окружении. 
               После выполнения функции её лексическое окружение уничтожается, а занятая им память освобождается.
               но есле ф-ция была возвращена то возникает замыкание
            это всё, что было объявлено до функции, в которой используется(!!!) эти объявления
                  const square = () => number ** 2;
                  const number = 5;
                  square(); // 25
               главное, что вызов функции square происходит позже определения number, 
               а значит к этому времени идентификатор уже был добавлен в окружение, 
               внутри которого была создана функция square.
                  const square = () => number ** 2;
                  let number = 5;
                  square(); // 25
                  number = 3;
                  square(); // 9
                  обращение к number всегда вернет последнее присвоенное значение
                  а ф-ция square() стоновится завязаной на внешнею переменую
               подобная завязка на переменные,
               должна восприниматься как абсолютное зло. 
               т.к. порождает неявные зависимости, сложный код и отладку. 
                  функция должна быть чистой 
                     т.е. не зависеть от внешнего контекста.
            лексическое окружение есть у люблго объекта, модулей, а так же есть глобальное окружение --- глобальная область видимости
         замыкание это название функции внутреней функции которая          https://ru.hexlet.io/courses/introduction_to_programming/lessons/env/theory_unit 
            запоминает внешние переменные которые были использованы внутри неё
               т.е. после выполнения внешней ф-ции она удаляется вместе со своей областью видимости НО
                  значение переменной объявленной в ней сохранится
                  если это значение было использовано(?) внутри внутренней ф-ции.
                     const createPrinter = () => {
                        const name = "King";
                        const printName = () => {     // замыкание
                              console.log(name);
                           }
                        return printName;
                     }
                     const myPrinter = createPrinter();
                     myPrinter();    // King
               ф-ция которая была возвращена из createPrinter замыкает в себе переменную name
               получается что переменная сохраняется в замыкании 
         стрелочные функции они же лямда фукуции         https://youtu.be/PGnNVW5n-3g
            не создаёт свой контекст вызова а указывает на верхний контекст по стеку вызова
               пример  
               function(){
                  setTimeout(() => {
                     console.log(this)
                     },500)
               }
            const b = (a,b)=>{ return a + b }  // общий синтаксис
            const b = a =>{ return a ** 3 }  // если параметр один
            const b = a => return a ** 3  // если строчка одна
         параметры по умолчанию
            function(a=3,b=5){}
         Rest 
            function func(a, b, ...args){}      // массив args будет содержать любое колличество аргументов после двух первых
         Spred
            разворачивает переданный массив в строку
               let arr_1 = [1,2,3,4,5];
               console.log(...arr_1);      // в консоль  строка: 1 2 3 4 5
               const arr_2[9,9,7, ...arr_1]
                console.log(arr_2);      // в консоль  массв: [9, 9, 7, 1, 2, 3, 4, 5]
      строки
         записываются в кавычках
         одинарные и двойные кавычки равноправные
         обратвые кавычки 
            шаблоны строк
               в конструкции ${} может находиться всё что угодно переменные, вызовы функций, объекты, выражения
               let b = 20;
               console.log(`стрка ${b}`);   // в консоль: строка 20
            могут включать в себя любые другие кавычки
            сохраняют пробелы и переносы строк
            методы строк
               str.starstWith('что то');  // поиск подстроки в начале строки
               str.endsWith('что то'); // поиск подстроки в конце строки
               str.includes('что то');  // поиск подстроки
               str.repeat(5);   // дублирование строки указанное количество раз
               str.trim();    // удалить пробелы
      реструкторизация
         let arr_1 = [1,2,3,4,5];
         ES5:
            let a = arr_1[0];
            let b = arr_1[1];
         ES6:
            let [a,b, ...c] = arr_1;
         console.log(a, b);      // в обоих случаях в консоль  1 2 [3,4,5]
         значение по умолчанию
            let arr_1 = [1,undefined,3,4,5];
            let [a,b=70, ...c] = arr_1;
            console.log(a, b);      // в обоих случаях в консоль  1 70 [3,4,5]
         пропуск значения
            let arr_1 = [1,2,3,4,5];
            let [a,,c, ...d] = arr_1;
            console.log(a, c, d);      // в обоих случаях в консоль  1 3 [4,5]         
         
         в объёктах всё тоже самое но при передачи ф-ции кантекст нужно передавать в ручную
            const address = {
               country: 'Ukrain',
               city: 'Kiev',
               street: 'Tamma',
               concat: function() {
                     return `${this.country}, ${this.city}, ${this.street}`
                  }
            }
            const {city, country, street, concat: addressConcat} = address
            console.log(сoncat.call(address))      // кантекст передан в ручную
         создать новый объект изменив и добавив некоторые поля
            const newAddress = {...address, street: 'Gogoly', code: 123}
            console.log(newAddress)
            // console.log(address.concat())
      модули   файлы -> отдельные модули !!!       https://learn.javascript.ru/modules-intro
         в браузере также существует независимая область видимости для каждого скрипта <script type="module">
            необходимо явно сказать браузеру, что скрипт является модулем, при помощи атрибута <script type="module">
               <!doctype html>
               <script type="module">
                  import {sayHi} from './say.js';
                  document.body.innerHTML = sayHi('John');
               </script>
            если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window, тогда получить значение переменной можно обратившись к window.user
         модули не работают локально. Только через HTTP(s)
            через протокол file://  директивы import/export не работают
         в модуле на верхнем уровне this не определён (undefined).
         в модулях всегда используется режим use strict
         модуль имеет свою собственную область видимости
         для того что бы переменные (функции и т.д) были видимы в других файлах
            export let b = 1;
            import { b, funck } from 'путь к модулю'; 
            import * as my_import from 'путь к модулю';
         экспорт по дефолту
            export default {
               function func(){}
            }
            import my_def_import, { b, funck } from 'путь к модулю';    // не привязано к имени области  export default (!!??)
               my_def_import.func();
      объекты  
         создание
            с нуля
               летеральноя нотация или летерал объекта:
                  const person = {}
            на базе ранее существующих  
               object.assign  копирует значение всех собственных перечисляемых свойств из одного или более исходных объектов в целевой объект
                  при этом последующие свойства перезаписывают предыдущие
                  после копирования он возвращает целевой объект
                  const person = object.assign({})   
               спред оператор    скопирует все свойства одного объекта в другой
                  const person = {}         
                  const newperson = {
                     ...person,
                     newfield: "добаволяемое свойство"
                  }
         перебор ключей
            Object.keys()   возвращает массив из собственных перечисляемых свойств переданного объекта 
            Object.entries() возвращает массив собственных перечисляемых свойств указанного объекта в формате [key, value]
            пасле преобразования в массив обычными цыклами
               const keys = Object.keys(person)
               for(const key of keys){}
               const entries = Object.entries(person)
               for(const [key, value] of entries){
                  console.log(`${key} : ${value}`)
               }
         перебор зночений
            Object.values()   возвращает массив значений перечисляемых свойств объекта
               const values = Object.values(person)
               for(const value of values){}

         Object.freeze() замораживает объект: это значит, что он предотвращает 
            добавление новых свойств к объекту, 
            удаление старых свойств из объекта и 
            изменение существующих свойств или значения их атрибутов перечисляемости, настраиваемости и записываемости. 
            В сущности, объект становится эффективно неизменным. Метод возвращает замороженный объект
         Object.seal() запечатывает объект, предотвращая добавление новых свойств к объекту и делая все существующие свойства не настраиваемыми

      классы      устроены на основании прототипов  __proto__ 
         создать класс
            class MyClass {
                  construktor(param_1){
                  this.param_1 = param_1;
               }
               field_1 = 'значение поля 1';
               metod_1(){
               }
            }
            const instance = new MyClass(param_1);
            instance.metod_1();
            console.log(instance.field_1);
         наследоваие
            class MySecondClass extends {
                  construktor(param_1, param_2){
                     super(param_1)    // передать параметр в клас родитель
                     this.param_2 = param_2;    
                  }
               field_1 = 'значение поля 1';  // переопределить поле класса родителя
               metod_1(){        // переопределить метод класса родителя
                  super.metod_1();     // обращение к методу родителя
                  .... code .....
               }
            }  
         статические методы и поля        ???????????????
            statick metod_3(){}
         динамические ключи
            class MyClass {
                  construktor(param_1){
                  this.param_1 = param_1;
               }
               [dinam_key] : 'что то';
               field_1 = 'значение поля 1';
               metod_1(){
               }
            }            
         гетеры и сетеры 
      символы
         тип данных который появился в ES6 
         задаёт уникальные ключи (значения)
      генерация ошибок
         throw new Error('текст ошибки');
         try{
            .... что то ....
         }catch(e){
            console.log(e);
         }
      генераторы и итераторы
      цыкл for (  of)  - перебирает элементы сущности
      промисы и массивы промисов
      async await
      set и map
      reflect 
      proxy
      import -- export
         вариант 1 в index.html
            перечислить в строгом порядке все файлы из которых прописывается импорт
               <script src="../build/js/script_1.js"></script>
               <script src="../build/js/script_2.js"></script>
               <script src="../build/js/main.js"></script>
            import - export не нужен
         вариант 2 import - export
            принято, не обязательно(!!) import в начале файла
            для нативного js расширение необходимо(!) при зборке webpack расширение можно опустить
            index.html подключать только файл в котором прописан импорт обязательно указать type="module"
               <script type="module" src="../build/js/main.js"></script>      
            export default -- экспорт по умолчанию
               эксрортировать по умолчанию можно только один блок из обного файла
                  import псевдоним(!!)_того_что_импортируется from 'путь_откуда_импорт.js' 
            import - export
               каждая ф-ция или класс в файле экспортируется отдельно
                  export funktion fun_1(){}
                  export funktion fun_2(){}
                  export default  funktion fun_3(){}
                  тогда:
                     import fun_3, {имя(!)_того_что_импортируется_1, имя(!)_того_что_импортируется_2} from 'путь_откуда_импорт.js'
                  или с псевдонимами:
                     import alias_fun_3, {имя(!)_того_что_импортируется_1 as alias__того_что_импортируется_1, имя(!)_того_что_импортируется_2 as alias__того_что_импортируется_2} from 'путь_откуда_импорт.js'
                  или всего под одним псевдонимом
                     import * as alias_main from 'путь_откуда_импорт.js'

                     alias_main.имя(!)_того_что_импортируется_1;
                     alias_main.имя(!)_того_что_импортируется_2;

               методы и поля класса могут эксрортироваться отдельно от класса
                  let myClass = {
                     fild_1 : "",
                     fild_2 : 23,
                     method_1 : function(){
                        ....  .... ....
                     },
                     method_2 : function(){
                           ....  .... ....
                        },
                  }
                  export const alias_fild_1 = myClass.fild_1;
                  export const alias_method_2 = myClass.method_2;

               динамический импорт
                  import('путь_путь_откуда_импорт')   // возвращает промис
                  import('путь_путь_откуда_импорт').then((имя(!)_того_что_импортируется)=>console.log(имя(!)_того_что_импортируется) )
               реекспорт 
                  один файл как точка входа 
                     export fun_3, {имя(!)_того_что_импортируется_1, имя(!)_того_что_импортируется_2} from 'путь_откуда_импорт.js'


----------------------- ТЕОРИЯ end ------------------------- 


----------------------- Практика start ---------------------

----------------------- Практика end -----------------------



----------------------- Проблемы -- решения start ---------

----------------------- Проблемы -- решения end -----------








----------------------- ЧЕРНОВИК -----------------------




