###

	Подробное описание 
		использования 
			html приёмов
			фреймворков
		создания
			элементов страницы

###

проверка структу страницы:  https://gsnedders.html5.org/outliner/


-----  Теоритические основы вёрстки	------
	Необходимые компаненты сайта
		страница авторизации 
		страница 404
			шаблон
		карта сайта
			шаблон
		главная страница
			шаблон
		шаблоны страниц 
			статический 
				по умолчанию, шаблон страницы выполняет одну фиксированную функцию 
					показ карты сайта 
					удаление  боковой панели для изображения страницы на всю ширину окна
					и д.р.
			динамический
		шаблоны записей
		локализация
		пагинация

	Семантические теги 
		предназначены для пояснения поисковым роботам четкой роли контента на странице
			т.е. несут смысловую нагрузку для поисковых систем
		отображаються настранице также как и обычные <div>
		не имеют стилей по умолчанию

		минимальный набор любой страницы:
		<html>, <head> и <body>
		в документе теги head и body могут быть использованы только один раз
		
		<html> 
			очень важен атребут lang=""
				атрибут lang можно задавать любым тегам если нужно уточнить
				на каком языке написан текст внутри тега. 
				но если задать его тегу <html>, то действие атрибута 
				распространится на весь документ целиком
		<head>
			предназначен для хранения служебной информации о странице
			располагается первым в теге <html>, сразу перед <body>
			содержит:
				тег <title> обязателен для поисковых роботов
					должен описывать содержимое документа в целом
					этот текс отображается
						в результатах поиск
						браузерных закладках
				теги подключения скриптов
		<meta ....  >
			одиночный
			распологаеться внутри тега <head>
			сообщает браузеру, поисковим роботам, другим устройствам служебную информацию -- метаинформацию
			<meta name="description" content=""/>
				это мета-описание страницы сайта. 
				действующий и достаточно эффективный способ влияния на представление сайта в результатах поиска
				содержимое параметра content используется при формировании сниппета для описания сайта в поиске
			<meta name="keywords" content="">
				отвечает за ключевые слова
			<meta charset="название кодировки">
		<nav></nav>
			для оформления блока навигации по сайту
			навигацию желательно оформлять єлементами
			пагинация страниц
		<main></main>
			обрамляет основное содержимое страницы 
			то что НЕбудет повторяться на другх страницах сайта
				т.е. сюда нельзя помещать сайтбары, хедеры, футеры и т.п.
			спецификация не допускает использование на одной странице более одного тега <main>
		<article></article>
			обрамляет блоки контента, которые могут быть вынуты из контекста страницы
			и использованы отдельно в другом месте  т.е.  независимый раздел
			пример: 
				статьи
				карточки фильмов или товаров
				превью и т.п.
			може иметь независимую от остального документа, иерархию заголовков
		<header></header>
			в отличии от HTML4 в HTML5 применим к блокам
			обрамляет вводный контент блока
			может содержать 
				заголовки 
				логотип
				имя автора
				дата публикации
				прочее
			не создает новый раздел в структуре HTML-документа
		<footer></footer>
			в отличии от HTML4 в HTML5 применим к блокам
			обрамляет завершающий контент блока
			например
				сноски
				ссылки
				выписки
				правовая инфа
				контакты
				прочее
			может содержать 
			элемент <address>
		<aside></aside>
			обрамляет раздел страницы, не связанный напрямую с основным контентом страницы
			например
				боковые панели
				рекламные блоки
				ссылки на архив
				прочее
		<section></section>
			обрамляет крупные смысловые разделы блока контента 
			которые не могут расмативаться отдельно от контента
			допускается вкладывать один элемент <section> внутрь другого
			може иметь независимую от остального документа, иерархию заголовков
		<h1></h1> 
			используется для указания заголовка контейнера в котором он находится
			формирует тектовую структуру блока
			это может быть header, section, article и т.д.
			т.е. на странице возможно несколько h1 
				до HTML5 h1 на страницемог быть только один
		<p></p>
			параграф в HTML структурная, а не смысловая сущность.
			группирует элементы с фразовым типом содержимого
				на пример
					блоки текста
					изображения
					ссылки
					поля ввода
					прочее
			формирует более мелкую, чем заголовок, текстовую структуру
			внутри абзаца не могут располагаться крупные структурные теги
			заголовки, формы, списки, таблицы. 
			когда браузер встречает неподходящий тег внутри <p>
			он «выбрасывает» этот тег из <p>.

	Flex-Box
		!!! блок может быть одновременно контейнером и элементом
			одному блоку -- два класса
				первый -- контейнера
				второй -- элемента
		технология создания адаптируемых блоков Flexbox
		особенности
			вертикальное выравнивание внутри родителя
			разнообразное распределение пространства 
				между соседями внутри контейнера
			выравнивание колонок по высоте 
				вне зависимости от наполнения
		flex-модель
			flex
				Термины:
					Главная ось (main axis)
						направление задаёться свойством flex-direction
						вдоль этой оси располагаються все Flex элементы
						Начало и конец этой оси называются main start и main end.
					Поперечная ось (сross axis)  
						проходит перпендикулярно Flex элементам
						начало и конец этой оси называются cross start and cross end.
					flex container
						родительский элемент 
						в котором установлено
							display: flex или 
							display: inline-flex
					flex items
						дочерние элементы флекс контейнера
			-inline-flex
				блоки распологаються как строчные
		Свойства
			позиционирование flex-блоков
				flex-direction
					устанавливается для flex-контейнера
					задаёт направление главной оси
						по умолчанию
							flex-direction: row;
					flex-direction: row;
						Главная ось направлена так же, как и ориентация текста, 
							по умолчанию слева направо
					flex-direction: column
						Главная ось располагается вертикально и направлена сверху вниз
					flex-direction: row-reverse;
						то же что и row только в противоположном направлении
					flex-direction: column-reverse
						то же что и column только в противоположном направлении
				flex-wrap
					устанавливается для flex-контейнера
					устанавливает возможность при необходимости(!) 
						распологать flex-элементы в несколько строк
							по умолчанию
								flex-wrap: nowrap;
					при этом высота контейнеров выравнивается по максимальному
					nowrap
						флексы выстраиваются в одну линию
							т.е. перенос на другую строку запрещён
					wrap
						флексы выстраиваются в несколько строк
							если ширины контейнера не хватает(!)
						направление задаётся свойством flex-direction
					wrap-reverse
						то же что и wrap, но в сторону противоположную flex-direction
				flex-flow
					сокращённая форма записи
						flex-flow: row wrap;
							аналог
						flex-direction: row;
						flex-wrap: wrap;				
			размеры flex-блоков  подробнее: !!!! https://developer.mozilla.org/en-US/docs/Web/CSS/flex
				ширина
					устанавливаються пропорционально(!) от всего доступного размера	
					сокрращённая запись
						пр:
							flex 1 1 auto
								блок займёт всю доступную ширину
					0 - запрет на расширение или сужение
						пр:
							flex 0 0 500 px
								фиксированный размер блока 500 px
					flex-grow
						коэффициент расширения флекса в контейнере 
						задаёт, насколько элемент будет увеличиваться  
						по отношению к другим флексам			
					flex-shrink
						устанавливается для элемента
						коэффициент сжатия флекса в контейнере 
						задаёт, насколько элемент будет уменьшаться 
						по отношению к другим флексам
					flex-basis
						определяет первоначальный размер элемента
							меньше которого элемент быть не может
						в px, mm, pt или в процентах
						размер вычисляется относительно родителя
						отрицательное значение недопустимо
				высота
			выравнивание	
				вдоль основной оси
					justify-content
						устанавливается для контейнера
						устанавливает правила распределения пространства 
							вокруг элементов
						выполняется после того как 
							будут применены размеры и автоматические отступы
								за исключением ситуации, когда по крайней мере у одного элемента 
									flex-grow больше нуля
									при этом не остаётся никакого свободного пространства 
						по умолчанию
							flex-start
						flex-start
							Флексы прижаты к началу строки
						center
							Флексы выравниваются по центру строки
						space-between
							Флексы равномерно распределяются по всей строке 
								при этом
										первый и последний элемент прижимаются к соответствующим краям контейнера
						space-around
							Флексы равномерно распределяются по всей строке
								при этом 
									пустое пространство перед первым и после последнего элементов 
									равно половине пространства между двумя соседними элементами
						space-evenly
							Флексы распределяются так, что
							расстояние между любыми двумя соседними элементами
							а также перед первым и после последнего
							было одинаковым
				вдоль поперечной оси
					align-items !!! если это свойство скопировать именно отсюда и вставить в css фай работать не будет МИСТИКА!!!
						устанавливается для контейнера
						устанавливает расположение элементов НЕ СТОРОК 
							вдоль поперечной оси
						по умолчанию
							align-items: stretch;	
						align-items: flex-start
							флексы выравниваются в начале поперечной оси контейнера
						align-items: flex-end
							флексы выравниваются в конце поперечной оси контейнера
						align-items: center
							флексы выравниваются по линии поперечной оси
						align-items: baseline
							флексы выравниваются по их базовой линии 
								базовой линии это 
									воображаемая линия проходящая по нижнему краю букв
						align-items: stretch	
							флексы растягиваются таким образом, чтобы 
							занять всё доступное пространство контейнера			
					align-content
						устанавливается для контейнера
						устанавливает выравнивания СТРОК (рядов) 
							элементов внутри контейнера вдоль поперечной оси 
							при наличии свободного пространства
						по умолчанию
							align-content: stretch;	
						flex-start
							строки располагаются в начале поперечной оси. Каждая следующая строка идёт вровень с предыдущей.
						flex-end
							строки располагаются начиная с конца поперечной оси. Каждая предыдущая строка идёт вровень со следующей.
						center
							строки располагаются по центру контейнера.
						space-between
							строки равномерно распределяются в контейнере и расстояние между ними одинаково.
								при этом
										первый и последний элемент прижимаются к соответствующим краям контейнера						
						space-around
							строки равномерно распределяются таким образом, чтобы пространство между двумя соседними строками было одинаковым. Пустое пространство перед первой строкой и после последней строки равно половине пространства между двумя соседними строками.
						space-evenly
							строки распределяются равномерно. Пустое пространство перед первой строкой и после последней строки имеет ту же ширину, что и у других строк.
						stretch
							строки равномерно растягиваются, заполняя свободное пространство.
					align-self 
						устанавливается для элемента
						выравнивает флекс-элементы текущей строки,
							переписывает значение align-items
						по умолчанию
							align-items: auto;	
						!! Если margin в поперечной оси выставлен в auto, то align-self
			порядок вывода флексов
				order
					устанавливается для элемента
					устанавливает порядок вывода флексов внутри флекс-контейнера
						Элементы располагаются согласно значениям свойства order от меньшего к большему
						от начала главной оси
							При равных значениях order 
								элементы выводятся в том порядке
								в каком они появляются в исходном коде
					по умолчанию			
						order: 0;
					допускаются 
						-1 
							тогда этот элемент отобразится раньше 
							элемента с order: 0;

	Bootstrap

	Grid CSS

	Позиционирование
		устанавливает позицию элемента в документе
		при помощи свойств
			top
				в приоритете перед bottom
				растояние от верхнего края элемента
			bottom
				растояние от нижнего края элемента
			right
				в приоритете перед 
				растояние от правого края элемента
			left
				растояние от левого края элемента
			auto
				свойство считаеться не установленным
			ширина поля добавляются к смещению
				
		!! позиционируеться ТОЛЬКО тот элемент 
			у которого 
				вычисленное(!!) значение position 
					relative, absolute, fixed либо sticky
			относительное позиционирование
				relative
					Элемент позиционируется в соответствии с нормальным потоком документа, 
						потом смещается относительно себя на основе значений top, right, bottom и left. 
					Смещение не влияет на положение любых других элементов; 
						таким образом, пространство, заданное для элемента в макете страницы, не меняеться(!!)
					Создаёт новый контекст наложения, когда значение z-index не auto
			абсолютное позиционирование 
				задают смещения от края блока содержащего элемент
				выпадает из нормального поттока документа
					т.е. располагаеться под остальными элементами
				absolute
					Элемент удаляется из обычного потока документа
						т.е. пространство, заданное для элемента в макете страницы, удаляеться(!!) 
						позиционируется относительно его ближайшего относительно(!) позиционированного предка 
						если такого предка нет єлемент помещается относительно исходного содержащего блока. 
						его конечная позиция определяется значениями top, right, bottom, и left.
						создаёт новый контекст наложения, когда значение z-index не auto. 
						поля абсолютно позиционированных коробок не сворачиваются с другими полями.			
					В большинстве случаев 
						абсолютно позиционированный элементы 
						с height и width 	установленные в auto
						имеют размер по содержимому

						Тем не менее, незамещаемые, абсолютно позиционированный элементы можно сделать такими, чтобы они заполнили доступное вертикальное пространство, указав как top, так и bottom, и оставляя height неопределённым (то есть , auto). Ими также можно заполнить доступное горизонтальное пространство, указав как left (en-US), так и right, и оставляя width как auto.
			fixed
				позволяет элементу находиться в обычном его состоянии, расположенном на своём месте в документе. 
				Свойства top, right, bottom, left и z-index не применяются к данному элементу		
			sticky
		!! содержащий блок
			однозначно устанавливается значением 
			свойства position	
				static, relative, или sticky тогда
					краем content бокса 
					ближайшего предка 
						который:
							является блочным контейнером (block container), 
								его свойство display установлено 
									inline-block
									block
									list-item
							устанавливает контекст форматирования (formatting context), 
								блочный контейнер (block container)
								flex-контейнер (flex container) 
								grid-контейнер (grid container) 
								контейнер таблицы (table container)
				absolute
					краем padding бокса 
					ближайшего предка
						position которого 
							fixed, absolute, relative или sticky
							(всё кроме fixed)
				fixed
					в случае непрерывного медиа (continuous media) областью просмотра (вьюпорт - viewport);
					в случае страничного медиа (paged media) областью страницы.
				absolute или fixed
					краем padding бокса 
					ближайшего предка
						у которого:
							transform или perspective
								отличное от none
							will-change 
								transform или perspective.
							filter  
								отличное от none 
								will-change value of filter (работает только в Firefox).
							contain 
								paint

	Шрифты

	Размеры блоков
		Размер блока по умолчанию
			ширина
				всё свободное место в строке
			высота
				нулевая или auto
					т.е.
						по содержимому
		Внутриний размер
			тот который вставляемый элемент (картинка и т.п.) имеет изначально
		Внешний размер
			назначаеться на странице
		Ширина блока 
			устанавливается свойством width
				по умолчанию width она равняется ширине внутренней области, 
					но если 
						box-sizing имеет значение border-box, 
						то она будет равняться ширине области рамки.

			min-content, max-content, fit-content, stretch в CSS
		Высота блока
			задаёться
				в процентах
					устанавливает высоту блока по отношению к высоте родителя
						если !!
							высота родителя не задана явно(!) т.е. зависит от высоты содержимого
						и 
							элемент позиционирован не обсолютно
						тогда
							высота блока будет расчитана как auto (!!!)

	текст и шрифты
		!!! все свойства шрифта и текста наследуются
			по этому
				основной шрифт и основные стили текста прописывабться для <body>
				для остальных тегов уточняются по необходимости
			исключения
				font-family не наследуются для
					<form>, <input>, <textarea>, <button>
		Подключение шрифтов		https://www.youtube.com/watch?v=GwA0BN5RgB0&t=109s&ab_channel=%D0%A4%D1%80%D1%96%D0%BB%D0%B0%D0%BD%D1%81%D0%B5%D1%80%D0%BF%D0%BE%D0%B6%D0%B8%D1%82%D1%82%D1%8E
			@font-face
				внутри конструкции @font-face может находиться набор свойств шрифтов
					font-family: Pompadur; /* Имя шрифта */ 	
					font-size:
					font-style:
					src: url(URI), где URI — относительный или абсолютный путь к файлу.
					и др. 
				пример:
					@font-face {
						font-family: 'museo_sans_cyrl';
						src: url('../fonts/museosanscyrl-100.woff2') format('woff2'),
							url('../fonts/museosanscyrl-100.woff') format('woff');
						font-weight: 100;
						font-style: normal;
					}
			Google Fonts	https://fonts.google.com/
				непосредственно с сайта:
					найти нужный шрифт в поиске сайта
					перейти на страницу шрифта
					нажать:
						"select this font"
						в всплывающем окне выбрать 
							вкладка  "CUSTOMIZE"
								вариацию щрифта т.е. стиль
								язык
									кирилица
									латинский
							вкладка  "EMBET"
								в зависимости от варианта подключения
									CSS:
										вкладка "STANDART"
											скопировать 
												ссылку типа: <style>....</style> 
											вставить
												её в заголовок index.html 
												перед подключением стилей
									SASS:
										вкладка "IMPORT"
											скопировать
												всё между тегами <style>....</style> но без тегов(!)
													строку типа:
														@import ......
											вставить 
												в начало файла SCSS 
			Откудато из интернета:
				скачать в папку fonts
					источники:
						https://nomail.com.ua  (+)
				конвертировать:
					так как разные браузеры используют разные форматы шрифты
					конвертеры:
						http://www.font2web.com/ (-)
						https://transfonter.org/ (++)
					скачать в папку fonts
					разархивировать в папку fonts
						файлы шрифтов разных форматов в папку fonts
						из файлов стилей каждого шрифта
							скопировать весь код в начало файла стилей сайта
								это и есть подключение шрифтов
					изменить правила в font-face
						пути к файлам шрифтов
						имена шрифтов (не обязателено)
		Основные параметры 
			font-family: "имя шрифта";
				устанавливает шрифт для:
					всей страницы:
						т.е. преобладающий шрифт 
					отдельных блоков
			fon-size
			font-style
				тип начертания 
					курсив, наклонный и т.д.
			font-weight
				насыщеность (вес)
					значения
						буквенные
							пример
								font-weight: bold; /*жирный шрифт*/

						цыфровые
							пример
								font-weight: 700; /*жирный шрифт*/
			color
			text-align
				определяет 
					горизонтальное выравнивание текста
			text-decoration
				определяет
					подчеркивание, зачёркивание и т.п.
					none - убирает все эфекты
			text-shadow
			text-transform
				переводит текст В
				заглавные или прописные буквы
			text-ident
				определяет
					отступ первой строки блока текста
			letter-spacing
				определяет
					интервал между символами
			word-spacing
				определяет
					интервал между словами
			whith-space
				определяет 
					свойства пробелов между словами
			line-height
				определяет
					междустрочный интервал

	картинки, иконки и прочая графика
		контентные
			растровые
				jpeg/jpg	
					хорошо оптимизируется
				webP
					хорошо оптимизируется
					поддержавает прозрачность
					поддерживается не всеми браузерами!!
		фоновые
			растровые
				png
					плохо сжимается
					поддерживает прозрачность 
		Элементы дизайна   
			В идеале, все изображения в элементах интерфейса должны быть в формате svg.
			векторные
				иконки
						SVG 
							по сути язык разметки 
								с тегами атребутами и т.п.
				шрифты
			ico
				favicon.ico
					поддерживает прозрачность
			Иконочный шрифт
				https://www.youtube.com/watch?v=QYwI3LRCnRE&ab_channel=%D0%A4%D1%80%D0%B8%D0%BB%D0%B0%D0%BD%D1%81%D0%B5%D1%80%D0%BF%D0%BE%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8-IT%D0%B8%D1%84%D1%80%D0%B8%D0%BB%D0%B0%D0%BD%D1%81
				на иконки действуют все css правила шрифтов
				создание иконочных шрифтов
					из набора SVG картинок:
						https://icomoon.io
				подключение
					https://fontawesome.com
						регистрация на сайте
							в личном кабинете получить строку JS для подключения шрифтов
							разместить полученную строку в конце HTML страницы 
						скачать иконочный шрифт в папку проекта (может быть всего одна иконка)
							перенести 
								в папку 
									стилей файл стилей иконок
								в папку 
									проекта попку иконочных шрифтов
							подкорректировать пути к папке иконочных шрифтов 

							
				отображения иконки
					подключить иконочный шрифт к HTML
					добавить элементу класс иконки
						при этом к стилям элемента добавляется псевдо элемент ::before

	Кнопки
		<button>.......</button>
			внутри можно размещать любые элементы HTML
			может находиться в любом месте страницы
				!!!
					если нужно спомощью этой кнопки отправить данные на сервер 
						кнопка должна быть внутри формы
		<a class="что то" type="submit" >что то </a>
		<input> (с атрибутом type="button | reset | submit")	 


-----  Теоритические основы вёрстки	end		------

-----  Приёмы вёрстки	------
	Повышение надёжности вёрстки
		для текстовых блоков
			тестирование текстовых блоков на переполняемость !!
				одино из решений:
					высота блока - auto
			обязательно устанавливать
				между строчный отступ
		для форм
			поле textarea 
				ограничевать возможность пользователя менять размеры поля
				свойство resize: none
			стилизация полей на которых фокус
		для блоков-обёрток изображений
			тестирование блоков-обёрток изображений на изображения разных размеров + адаптив картинок
		для блоков-обёрток карточек или других блоков
			предусматривать возможность изменения количества блоков
				решения
					flex-wrap: wrap;
		-- использоваие селекторов типа
			- все объекты контейнера первого уровня
			- last-child
			и т.п.
		-- высоту строчки текста задавать в процентах
			line-height: calc(шрифт/высота строки *100%); /*или просто 120%*/	
			подробнее
				https://www.youtube.com/watch?v=f-irDQwt1l4&ab_channel=%D0%A4%D1%80%D0%B8%D0%BB%D0%B0%D0%BD%D1%81%D0%B5%D1%80%D0%BF%D0%BE%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8-IT%D0%B8%D1%84%D1%80%D0%B8%D0%BB%D0%B0%D0%BD%D1%81
		-- для того что бы блоки с текстом, например пункты меню, 
			были равной высоты независимо от количества текста в них
				align-items: stretch;
		-- указывать минимальные и максимальные размеры блоков
	
	Приёмы повышения скорости вёрстки
		Практика!!!!
		Аналмз макета
			приходит с практикой
		Повышение скорости набора
			слепой набор
		Среда разработки
			изучать возможности решения возникающих задач
			снипеты 
		Готовые фрагменты кода
			хранение - накопления
				gist
					плагин для VC-cod
		БЭМ
		Препроцессоры
		Системы сборки
	
	Выравнивание блока по центру экрана
		Подробнее:	
			https://www.youtube.com/watch?v=FdcwNozRkqE
			онлайн тренажор
				http://howtocenterincss.com/
		Всегда(?):
			html, body{
				width: 100%;
				height: 100%;
			}
		1.	position
				элементу:
					высота элемента известна и фиксирована
						position: absolute;
						/*погоризонтали*/
							left: 0px;
							right: 0px;
							margin: 0px auto;
						/*по вертикали:*/
							top: calc(50% - половина высоты элемента)
					если высота элемента неизвестна
						# по вертикали:
							top: 50%;
							transform: translate(0, -50%);
		2. FlexBox
				высота элемента известна и фиксирована
					flex-conteiner{
						display: flex;
						justify-content: center;
						align-items:center;
						height: 400px;
						max-width: 400px;
						position: absolute;
						top: calc(50% - 200px);	/*половина высоты элемента*/
						left: 0px;
						right: 0px;
						margin: 0px auto;
					}				
				высота элемента неизвестна
					flex-conteiner{
						display: flex;
						justify-content: center;
						align-items:center;
						height: 100%;
					}
		3. GRID
				grid-conteiner{
					display: grid;
					justify-items: center;
					align-items: center;
					height: 100%;
				}
		4. при помощи псевдо элемента
			используеться редко, 
			но поддерживается всеми браузерами, в т.ч. старыми
				.container{
					position: absolute;
					left: 0px;
					top: 0px;
					text-align: center;
					width: 100%;
					height: 100%;
					font-size: 0px;  /* высота content: ''; */
				}
				.container::before{
					content: '';
					display: inlin-block;
					vertical--align: middle;
					height: 100%;
				}
				.elenemt{
					display: inlin-block;
					vertical-align: middle;			
				}	
		5. при помощи таблиц
			устаревший метод
				.container{
					display: table;
					width: 100%;
					height: 100%;
				}
				.elenemt{
					display: table-cell;
					vertical-align: middle;
					text-align: center;
				}

	Размеры элементов
		Простая верстка
			высота
				min-height
					устанавливать для предотвращения схлопывания
					при отсутствии
				max-height
					устанавливать для предотвращения разррывов в верстке 
					в следствии неожибанно большого кол-ва контента
				height
					если 
						высота блока в макете фиксирована
							фиксация высоты может быть в том числе и процентами
			ширина
				min-width
					устанавливать для предотвращения схлопывания  
				max-width
					устанавливать для предотвращения разррывов в верстке 
					в следствии неожибанно большого кол-ва контента				
				width
					если
						ширина блока в макете фиксирована
							фиксация высоты может быть в том числе и процентами				
		FLEX верстка
			высота
				специальных средств FLEX для задания высоты нет!
				может быть задана свойством flex-basis
					если 
						flex-direction установлен в column
			ширина
				установлевается
					flex-basis	
		GRID верстка
			высота
			ширина		
		Bootstrap верстка
			высота
			ширина		

	menu
		разметка (структура) типа 
			<nav id="menu-">
				<ul> 
					<li><a href="/">content</a></li>
					<li><a href="/">content</a></li>
				</ul>
			</nav>
			!!!!! много крутых менюшек с кодами:
				https://www.creativosonline.org/ru/menu-html-css.html?_gl=1%2A1h6tqji%2A_ga%2AYW1wLUZmdV9rM040VDlqOXJ2dXRwbU5ZSVVZWHM2emFFNmlsRGxUWlUzMUJHQUwtM1Ywc3preXI4Z1QyeFd4NlVOMnA.#Menu_circular_CSS_HTML
		горизонтальное меню
			разметка не меняеться
			стили
				обнулить стили браузера по умолчанию для элементов навигации:
					ul {
							list-style: none; /*убираем маркеры списка*/
							margin: 0; /*убираем верхнее и нижнее поле, равное 1em*/
							padding-left: 0; /*убираем левый отступ, равный 40px*/
						}
					a {text-decoration: none; /*убираем подчеркивание текста ссылок*/}
				Способ 1. li {display: inline;}
					Делаем элементы списка строчными. 
						В результате 
							они располагаются по горизонтали, 
							с правой стороны между ними добавляется промежуток, 
							равный 0.4em (вычисляется относительно размера шрифта). 
								Чтобы убрать его убрать, 
									добавляем для li отрицательное правое поле 
									li {margin-right: -4px;}. 
							Дальше стилизуем ссылки по своему желанию.
				Способ 2. li {float: left;}
					Делаем элементы списка плавающими. 
						В результате 
							они располагаются по горизонтали. 
						При этом высота блока-контейнера ul становится равной нулю. 
							Чтобы решить эту проблему, 
								для ul
									ul {overflow: hidden;}, 
										расширяя его 
										и позволяя ему таким образом содержать плавающие элементы. 
								для a
									a {display: block;} 
									и стилизуем их по своему желанию.
				Способ 3. li {display: inline-block;}
					Делаем элементы списка строчно-блочными. 
						В результате
							Они располагаются по горизонтали, 
							с правой стороны образуется промежуток, как и в первом случае. 
						Для a
							a {display: block;} 
							и стилизуем их по своему желанию.
				Способ 4. ul {display: flex;}
					Делаем список ul гибким контейнером с помощью модели CSS3 flexbox. 
						В результате 
							элементы списка располагаются горизонтально. 
						для a
							a {display: block;} 
							и стилизуем их по своему желанию.

	Отступы
		https://www.youtube.com/watch?v=uSGKPYEPY9M&t=14s&ab_channel=%D0%A4%D1%80%D0%B8%D0%BB%D0%B0%D0%BD%D1%81%D0%B5%D1%80%D0%BF%D0%BE%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8-IT%D0%B8%D1%84%D1%80%D0%B8%D0%BB%D0%B0%D0%BD%D1%81
		принцыпы применения 
			- отступы нужно задавать от предидущего элемента к следующему
				т.е.
					сверху вниз
					слева на право
			- у последнего элемента группы отступ нужно обнулить
				пример	
					li:last-child{
						margin: 0px 0px 0px 0px ;
					}
			- отступы задаются сомому верхнему родителю в конструкции
			- внешние отступы нужно задавать не БЭМ блокам, а БЭМ элементам	
				т.е.
					нужно использовать "микс классы"
					при этом 
						все стили для блока прописываються в класе блока
						а отступы в класе элемента
					пример:
						.title{
							color: red;
							background-color: green;
						}
						.block-1__title{
							margin: 0px 50px 0px 0 px;
						}
						.block-2__title{
							margin: 0px 40px 0px 0 px;
						}
						.block-3__title{
							margin: 0px 20px 0px 0 px;
						}

						<div class="block-1__title title "></div>
						<div class="block-2__title title "></div>
						<div class="block-3__title title "></div>


		margin
			может быть отрицательным

		padding
			НЕ может быть отрицательным
			не применяеться для строчных элементов
			padding заданный для ссылки увеличивает "зону клика" для курсора

	Адаптивный шрифт  !!!
		https://www.youtube.com/watch?v=HJZP5QsrpXs&t=17s&ab_channel=%D0%A4%D1%80%D0%B8%D0%BB%D0%B0%D0%BD%D1%81%D0%B5%D1%80%D0%BF%D0%BE%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8-IT%D0%B8%D1%84%D1%80%D0%B8%D0%BB%D0%B0%D0%BD%D1%81
		.div{
			font-size: calc(FS_min + K * WС);
		}
		@media(max-width: 767px){
			.div{
				font-size: calc(FS_min + K_mob * WС_mob);
			}
		}
			ГДЕ:
				FS_min - минимальный размер шрифта в px
					т.е размер шрифта который длжен быть на минимальном экране
				FS_start - размера шрифта по макету в px
					т.е. размер шрифта который должен быть на основном (большом экране)
				K - добавочный коэффициент без размерный
					определяет плавность изменеия размера шрифта
						K = FS_start - FS_min
				K_mob - добавочный коэффициент для маленьких экранов без размерный
					K_mob = ((FS_start - FS_min) + (FS_start - FS_min) * 0.7)
				WidthTemplate - ширина макета
				W_min - ширина самого маленького экрана
				WС - текущая ширина экрана
					WС = 100vw / WidthTemplate
				WС_mob - текущая ширина для маленьких экранов
					WС_mob = (100vw - W_min) / WidthTemplate

	Адаптив картинок 
		https://www.youtube.com/watch?v=nTtuiBXKp88&ab_channel=%D0%A4%D1%80%D0%B8%D0%BB%D0%B0%D0%BD%D1%81%D0%B5%D1%80%D0%BF%D0%BE%D0%B6%D0%B8%D0%B7%D0%BD%D0%B8-IT%D0%B8%D1%84%D1%80%D0%B8%D0%BB%D0%B0%D0%BD%D1%81
		!!! картинки подключаются только в HTML
		Контентные изображения
			ширина
				вместо width max-width:100%
			<picture>
				<source ... >
				<source ... >
				<source ... >
				<img src="/" alt=""> <-- для Internet Explorer -->
			</picture>
		Карточки
			! картинки могут быть разных размеров
			отзывчевая высота
				будет пропорционально изменяться вместе с шириной
				для родителя
					min-height: 100px;
					flex: 0 0 33.333%;	/*отзывчивая ширина*/
					overflow: hidden;
					position: relative;
					padding: 0px 0px 50% 0px; /*вместо(!!!) фиксированной высоты при нижнем отступе в 100% будет показана вся картинка*/
				для картинки
					width: 100%;
					height: 100%;
					position: absolute;
					top: 0;
					left: 0;
					object-fit:cover;
					object-position: center; /* или более подходящее значение*/

	Разделитель между блоками
		1. смещение бордеров
			.block{
				border-left: 3px solid red;
				padding: 0 20px;
				margin: 0 1px 0 -8px;
			}
			.block-wrap>div:nth-child(1) .bloc { /*т.е. первому из разделяемых блоков*/
				border-left: 3px solid #d4d0d1;
				padding: 0 20px;
				margin: 0 0 0 -2px;
			}
			.block-wrap>div:nth-last-child(1) .block { /*т.е. последнему из разделяемых блоков*/
				border-right: 3px solid #d4d0d1;
				width: auto; /*из-за отрецательного margin блок смещается в лево тогда правый бордер смещён внутрь блока*/
			}
		2. фоновым изображением
		3. svg иконка в ::after ::before

	Непрямоугольные блоки при помощи CSS-форм
		псевдо элементы
			используется для
				скошенные углы, как правило
			https://www.youtube.com/watch?v=4-5JoIEISE8
		<shapes>
			Все HTML-элементы имеют 
				прямоугольную блочную модель, 
				которая управляет потоком содержимого внутри и снаружи нее
			Объявление формы
		CSS свойство clip-path:
			Создаёт ограниченную область, которая определяет какая часть элемента должна быть видимой. 
			Обрезанная область - это траектория, определяемая как
				внутренняя ссылка
				внешний SVG
				фигура, такая как круг (circle()).
			проблем:
				не поддерживает border !!!
			решение:
				совмещать идентичные фигуры разного размера
				цвет границы при этом определяет фон нижней фигуры
					пример:
						.shape {
						width: 400px;
						height: 40px;
						background-color: black;
						position: relative;
						}
						.shape:before {
						content: '';
						width: 398px;
						height: 38px;
						background: #00c000;
						display: block;
						position: absolute;
						top: 1px;
						left: 1px;
						}
						.shape, .shape:before {
						-webkit-clip-path: polygon(5% 0, 100% 0, 100% 100%, 0 100%, 0 100%);
						clip-path: polygon(5% 0, 100% 0, 100% 100%, 0 100%, 0 100%);
						}
						
						<div class="shape"></div>

	Слайдер
		Принцып работы
			-- два контейнера
					наружный
						ограниичивает слайдер
					внутренний
						формирует зону показа слайдов
						скрывает слайды перед показом
							overflow: hidden;
					слайды 
						размещаються
							во внутреннем контейнере
						показ
							за счёт смещения слайдов 
							из-за пределов внутреннего контейнера в зону показа
			-- стопка слайдов
					контейнер один
					слайды
						размещаються в контейнере
							position: absolute
						показ
							за счёт изменения z-index
			-- акардион
				верстаеться на флексах
				в зоне показа
					все слайды ограниченные по ширине
				показ
					при наведении курсора слайд разворачивается на всю ширину	
		Готовые
			SWIPER	https://youtu.be/ddbxsrGPRY0
			SLICK SLIDER	https://youtu.be/rXNfDfqtM3M
		Самописные
			JS
				function slider_1() {
					/*
						проматывает все элементы с лево на право и обратно
					*/

					let offset = 0;
					const sliderLine = document.querySelector('.wrap-slider-cards');
					let quantity_img = document.querySelectorAll('.wrap-slider-cards .slider-card').length
					// console.log("quantity_img = " + quantity_img);

					document.querySelector('#left').addEventListener('click', function () {
						if (offset > (quantity_img - 5) * 235) {
							return;
						}
						offset = offset + 235;
						sliderLine.style.left = -offset + 'px';
					});
					document.querySelector('#right').addEventListener('click', function () {
						if (offset < 1) {
							return;
						}
						offset = offset - 235;
						sliderLine.style.left = -offset + 'px';
					});
				}
			CSS
				принцып действия:
					смещение элементов в бок
					изменение прозрачности элементов
					изменение z-index
				структура:
					контейнер слайдера
						обязательные свойства:
							overflow: hidden;	
				контейнер для контента
					устанавливает общий размер блока с изображениями
						пример:
							width: 500%;
							line-height: 0;
				контент
					расположени рядом с контейнером
					пример:
						с права:
							width: 20%;
							float: left;
				управляющие элементы
					чекбоксы
						визуально скрыты
					обращение 
						при помощи тега label
					тригер:
						псевдо клас :checked
				
	Сетки
		общий принцып:
			дизайнер делит всю ширину страницы на нужное ему количество колонок
			каждый элемент занимает какое то количество колонок
				позиционируеться то же по колонкам
			пример характеристик страницы:
				columns = 12
				ofset = 30px - отступы между колонками
			пример характеристик элемента:
				n = 3 колонки - ширина
			общая формула для ширины элемента:
				width: calc(100% / columns * n - ofset*2(т.к. с двух сторон));
		адаптив:
			пример:
				.item{
					padding: 50px 0px;
					text-aling: center;
					bacrgraund: #f5d781;	
					width: calc(100% / 12 * 4 - 30px);		
					margin: 15px;					
				}

				@media screen and (max-weight: 920px){
					.item{
						width: calc(100% /  * 3 - 30px);
					}
				}

				@media screen and (max-weight: 520px){
					.item{
						width: calc(100% /  * 1 - 30px);
					}
				}


		grid 
			полноценные сетки
				т.е. монипуляция элементами по двум осям
		Flex
			эмуляция сеток:
				.container{
					max-widh: 1280px;
					margin: 0 auto;	/*центровка по горизонтали*/
					padding: 0 30px;
				}
				.row{
					display: flex;		/*все элементы на одной строке  по умолчанию при этом:
												flex-basis: auto; flax-wrap: no-wrap;
					flax-wrap: wrap;
					/*убрать пустое пространство между row и внешним краем item*/
						либо 
							margin: 0 -(margin установленный для item)px; 
						либо
							justify-content: space-between;
					margin: -15px;
					/*центровка блоков*/
					justify-content: center;
				}
				.item{
					padding: 50px 0px;
					text-aling: center;
					bacrgraund: #f5d781;
					/* т. к. по умолчанию box-sizing:content-box; 
							т.е. 
								реальная ширина элемента расчитываеться 
								от ширины контентной части в наружу  
									т.е. реальная ширина = ширина контентной части остаётся неизменной + padding + border + margin
						по этому для адекватной ширины элементов нужно
							либо 
								box-sizing: border-box; 
								а растояния между элементами устанавливать padding-ми
							либо:
								расчитывать ширину:
									width: calc((ширина одного єлемента в процентах) - (сумма левого и правого margin-ов в пикселях));
						*/
					width: calc(25% -30px);		
					margin: 15px;

				}

	Табы (вкладки)		https://itchief.ru/javascript/tabs
		В вебе табы – это просто набор ссылок или других HTML элементов, 
			которые визуально обычно оформляют в виде вкладок или группы кнопок. 
			При нажатии ни них они включают видимость одного какого-то блока с контентом 
			и скрывают другие.
		Реализация
			CSS 
				радиокнопки
					описание 
						В этом варианте радиокнопки связаны с определённым label. 
						Связь элемента label с input выполнена через атрибут for. 
						Это действие необходимо для того, чтобы можно было скрыть элементы input, 
						а управление ими (установку checked) выполнять через клики по элементам label.

						Стилизация выбранного элемента label в этом примере выполнена 
						с использованием селектора input[type="radio"]:checked+label. 
						Этот селектор выбирает элемент label, 
						который расположен сразу же после элемента input[type="radio"], 
						находящимся в состоянии checked.

						Отображение и скрытие контента, связанного с вкладками, выполняется очень просто. 
						По умолчанию элементы, содержащие контент, не отображаются. 
						Показ того или иного элемента с контентом осуществляется только в том случае, 
						если селектор в следующем правиле позволяет выбрать его:
							#tab-btn-1:checked~#content-1,
							#tab-btn-2:checked~#content-2,
							#tab-btn-3:checked~#content-3 {
							display: block;
							}				
					код
						<style>
						.tabs {
							font-size: 0;
						}

						.tabs>input[type="radio"] {
							display: none;
						}

						.tabs>div {
							/* скрыть контент по умолчанию */
							display: none;
							border: 1px solid #e0e0e0;
							padding: 10px 15px;
							font-size: 16px;
						}

						/* отобразить контент, связанный с вабранной радиокнопкой (input type="radio") */
						#tab-btn-1:checked~#content-1,
						#tab-btn-2:checked~#content-2,
						#tab-btn-3:checked~#content-3 {
							display: block;
						}

						.tabs>label {
							display: inline-block;
							text-align: center;
							vertical-align: middle;
							user-select: none;
							background-color: #f5f5f5;
							border: 1px solid #e0e0e0;
							padding: 2px 8px;
							font-size: 16px;
							line-height: 1.5;
							transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out;
							cursor: pointer;
							position: relative;
							top: 1px;
						}

						.tabs>label:not(:first-of-type) {
							border-left: none;
						}

						.tabs>input[type="radio"]:checked+label {
							background-color: #fff;
							border-bottom: 1px solid #fff;
						}
						</style>

						<div class="tabs">
						<input type="radio" name="tab-btn" id="tab-btn-1" value="" checked>
						<label for="tab-btn-1">Вкладка 1</label>
						<input type="radio" name="tab-btn" id="tab-btn-2" value="">
						<label for="tab-btn-2">Вкладка 2</label>
						<input type="radio" name="tab-btn" id="tab-btn-3" value="">
						<label for="tab-btn-3">Вкладка 3</label>
						<div id="content-1">
							Содержимое 1...
						</div>
						<div id="content-2">
							Содержимое 2...
						</div>
						<div id="content-3">
							Содержимое 3...
						</div>
						</div>				
				псевдокласс :target
					Псевдокласс :target предназначен для выбора элемента, 
						идентификатор которого соответствует хэшу в URL-адресе.
					Основная проблема
						перепрыгивание (прокручивание) страницы так что бы элемент с "id = :target" оказался в верху страницы
					Решение
						установка position:fixed для элемента с "id = :target" элемент может быть любым в примере это <br> 
						подробнее в "код 2"
					Описание	
						Логика этого способа основана на следующих моментах. 
							Первый момент заключается в добавлении хэша к URL-адресу страницы 
								при нажатии на ссылку (вкладку). 
							Второй – это стилизация элементов, выбор которых осуществляется в зависимости от 
								хэша в URL-адресе. 
					Выбрать элемент, идентификатор которого соответствует хэшу в URL-адресе в CSS 
						можно выполнить посредством псевдокласса :target. 
					С помощью него мы можем написать селектор 
						не только для получения элемента, на который он указывает, 
						но и для выбора других элементов, которые каким-то определённым образом связаны с ним.
					Например, выбрать вкладку, 
						которая должна быть активной для элемента на который указывает :target можно так:
							.tabs>#content-1:target~.tabs__links>a[href="#content-1"],
							.tabs>#content-2:target~.tabs__links>a[href="#content-2"],
							.tabs>#content-3:target~.tabs__links>a[href="#content-3"] {
							background-color: #bbdefb;
							cursor: default;
							}	
						или так:
							.menu1>div:nth-of-type(1),
							.menu1 #tab2:target~div:nth-of-type(2),
							.menu1 #tab3:target~div:nth-of-type(3) {
								display: block;
							}
					код 1: страница перепрыгивает на :target !!!!
						<style>
							.tabs {
							display: flex;
							flex-direction: column;
							}

							.tabs__links {
							display: flex;
							width: 100%;
							overflow-x: auto;
							overflow-y: hidden;
							margin-left: auto;
							margin-right: auto;
							margin-bottom: 10px;
							order: 0;
							white-space: nowrap;
							background-color: #fff;
							border: 1px solid #e3f2fd;
							box-shadow: 0 2px 4px 0 #e3f2fd;
							}

							.tabs__links>a {
							display: inline-block;
							text-decoration: none;
							padding: 6px 10px;
							text-align: center;
							color: #1976d2;
							}

							.tabs__links>a:hover {
							background-color: rgba(227, 242, 253, 0.3);
							}

							.tabs>#content-1:target~.tabs__links>a[href="#content-1"],
							.tabs>#content-2:target~.tabs__links>a[href="#content-2"],
							.tabs>#content-3:target~.tabs__links>a[href="#content-3"] {
							background-color: #bbdefb;
							cursor: default;
							}

							.tabs>div:not(.tabs__links) {
							display: none;
							order: 1;
							}

							.tabs>div:target {
							display: block;
							}
						</style>

						<div class="tabs">
						<div id="content-1">
							Содержимое 1...
						</div>
						<div id="content-2">
							Содержимое 2...
						</div>
						<div id="content-3">
							Содержимое 3...
						</div>
						<div class="tabs__links">
							<a href="#content-1">Вкладка 1</a>
							<a href="#content-2">Вкладка 2</a>
							<a href="#content-3">Вкладка 3</a>
						</div>
						</div>	
					код 2: страница НЕ перепрыгивает на :target 
						#tab2,
						#tab3,
						#tab4,
						#tab5 {
							position: fixed;
						}

						.menu1>a,
						.menu1 #tab2:target~a:nth-of-type(1),
						.menu1 #tab3:target~a:nth-of-type(1),
						.menu1>div {
							padding: 5px;
							border: 1px solid #aaa;
						}

						.menu1>a {
							line-height: 28px;
							background: #fff;
							text-decoration: none;
						}

						/* #tab2,
						#tab3,
						.menu1>div,
						.menu1 #tab2:target~div:nth-of-type(1),
						.menu1 #tab3:target~div:nth-of-type(1) {
							display: none;
						} */



						.menu1>div,
						.menu1 #tab2:target~div:nth-of-type(1),
						.menu1 #tab3:target~div:nth-of-type(1) {
							display: none;
						}





						.menu1>div:nth-of-type(1),
						.menu1 #tab2:target~div:nth-of-type(2),
						.menu1 #tab3:target~div:nth-of-type(3) {
							display: block;
						}




						.menu1>a:nth-of-type(1),
						.menu1 #tab2:target~a:nth-of-type(2),
						.menu1 #tab3:target~a:nth-of-type(3) {
							border-bottom: 2px solid #fff;
						}		

					<div class="menu1">
						<br id="tab2">
						<br id="tab3">
						<!-- <br id="tab4">
						<br id="tab5"> -->
						<a href="#tab1">1</a>
						<a href="#tab2">2</a>
						<a href="#tab3">3</a>
						<!-- <a href="#tab4">4</a>
						<a href="#tab5">5</a> -->
						<div>вкладка 1</div>
						<div>вкладка 2</div>
						<div>вкладка 3</div>
						<!-- <div>вкладка 4</div>
						<div>вкладка 5</div> -->
					</div>
			js
				Самописные:
					function tabs_1() {
						const tabs = document.querySelectorAll('.wrap-tabs>div');
						const title_tabs = document.querySelectorAll('.wrap-title-tabs>div');
						document.querySelector('.wrap-title-tabs').addEventListener('click', (e) => {
							for (let i = 0; i < tabs.length; i++) {
								tabs[i].className = "tab-hide";
								title_tabs[i].className = "title-tab";
							}
							document.querySelector('#tab-' + e.target.id).className = "tab-active";
							e.target.classList.add("title-tab-active");
						});
					}					
				Этот способ может потребоваться для решения задач, которые просто невозможно решить на CSS. 
					Например, когда нужно загружать контент динамически (через AJAX) в момент открытия вкладки.
				код
					<style>
					.tabs {
						border: 1px solid #e0e0e0;
					}

					.tabs__nav {
						display: flex;
						flex-wrap: wrap;
						list-style-type: none;
						background: #fafafa;
						margin: 0;
						border-bottom: 1px solid #e0e0e0;
					}

					.tabs__btn {
						padding: 0.5rem 0.75rem;
						text-decoration: none;
						color: black;
						text-align: center;
						flex-shrink: 0;
						flex-grow: 1;
						border: 1px solid transparent;
						cursor: pointer;
					}

					.tabs__btn_active {
						background: #e0e0e0;
						cursor: default;
					}

					.tabs__btn:not(.tabs__btn_active):hover,
					.tabs__btn:not(.tabs__btn_active):focus {
						background-color: #eee;
					}

					.tabs__content {
						padding: 1rem;
					}

					.tabs__pane {
						display: none;
					}

					.tabs__pane_show {
						display: block;
					}
					</style>

					<div class="tabs">
					<div class="tabs__nav">
						<button class="tabs__btn tabs__btn_active">Вкладка 1</button>
						<button class="tabs__btn">Вкладка 2</button>
						<button class="tabs__btn">Вкладка 3</button>
					</div>
					<div class="tabs__content">
						<div class="tabs__pane tabs__pane_show">
							Содержимое 1...
						</div>
						<div class="tabs__pane">
							Содержимое 2...
						</div>
						<div class="tabs__pane" id="content-3">
							Содержимое 3...
						</div>
					</div>
					</div>

					JavaScript (с использованием классов):

					class ItcTabs {
					constructor(target, config) {
						const defaultConfig = {};
						this._config = Object.assign(defaultConfig, config);
						this._elTabs = typeof target === 'string' ? document.querySelector(target) : target;
						this._elButtons = this._elTabs.querySelectorAll('.tabs__btn');
						this._elPanes = this._elTabs.querySelectorAll('.tabs__pane');
						this._eventShow = new Event('tab.itc.change');
						this._init();
						this._events();
					}
					_init() {
						this._elTabs.setAttribute('role', 'tablist');
						this._elButtons.forEach((el, index) => {
							el.dataset.index = index;
							el.setAttribute('role', 'tab');
							this._elPanes[index].setAttribute('role', 'tabpanel');
						});
					}
					show(elLinkTarget) {
						const elPaneTarget = this._elPanes[elLinkTarget.dataset.index];
						const elLinkActive = this._elTabs.querySelector('.tabs__btn_active');
						const elPaneShow = this._elTabs.querySelector('.tabs__pane_show');
						if (elLinkTarget === elLinkActive) {
							return;
						}
						elLinkActive ? elLinkActive.classList.remove('tabs__btn_active') : null;
						elPaneShow ? elPaneShow.classList.remove('tabs__pane_show') : null;
						elLinkTarget.classList.add('tabs__btn_active');
						elPaneTarget.classList.add('tabs__pane_show');
						this._elTabs.dispatchEvent(this._eventShow);
						elLinkTarget.focus();
					}
					showByIndex(index) {
						const elLinkTarget = this._elButtons[index];
						elLinkTarget ? this.show(elLinkTarget) : null;
					};
					_events() {
						this._elTabs.addEventListener('click', (e) => {
							const target = e.target.closest('.tabs__btn');
							if (target) {
							e.preventDefault();
							this.show(target);
							}
						});
					}
					}

					Инициализация табов:

					new ItcTabs('.tabs');

					Адаптивные вкладки на CSS и JavaScript

					Инициализация табов на странице осуществляется посредством создания нового объекта типа 
						ItcTabs и передаче ему в качестве аргумента CSS-селектор или DOM-элемент которой необходимо инициализировать как табы.

					Если в качестве аргумента указать селектор класса, то в качестве табов будет инициализирован только первый элемент.
					Для того чтобы на странице инициализировать несколько вкладок, можно использовать следующий код:

					const tabs = document.querySelectorAll('.tabs');
					for (let i = 0, length = tabs.length; i < length; i++) {
					new ItcTabs(tabs[i]);
					}

					Кроме этого, результат вызова new ItcTabs() можно сохранить в переменную, а затем использовать её для программного переключения вкладок.

					Например:

					const tab = new ItcTabs('.tabs');
					// программно переключиться на 2 вкладку (1 – индекс вкладки, на которую нужно перейти)
					tab.showByIndex(1);

					Краткое описание исходного кода JavaScript
					Исходный JavaScript построен на основе класса ItcTabs.
					В конструкторе:
						this._elTabs - это DOM-элемент, содержимое которого нужно инициализировать в качестве табов;
						this._elButtons - элементы, которые представляют собой вкладки;
						this._elPanes - элементы, содержащие контент, который необходимо переключать с помощью вкладок.
					Установка обработчика для события click осуществляется в методе _events(). Данный метод вызывается в конструкторе.
					Для отображения определённого контента в зависимости от нажатой вкладки выполняется с помощью метода show(). Элемент, на который нажали передаём в качестве аргумента:
					this.show(target);
					Метод showByIndex(index) предназначен для перехода на вкладку по её индексу.			

-----  Приёмы вёрстки	end		------


Всё обо всём 
	margin-right: 5%;    /* относительно ширины РОДИТЕЛЬСКОГО блока */