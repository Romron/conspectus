Источники:
   Установка Laravel
      https://laravel.su/docs/5.0/installation
   Композер
      https://habr.com/ru/post/439200/
      https://getcomposer.org/doc/03-cli.md
   все функции laravel
      https://laravel.com/docs/9.x/helpers#main-content
      https://laravel.ru/docs/v5/helpers
   о паролях MySQL
      https://webformyself.com/kak-uznat-parol-mysql-ili-ne-ishhem-priklyuchenij-na-svoyu-golovu/
   Руководства по Laravel 8
      ++ https://www.internet-technologies.ru/articles/ruk-po-laravel-8-kak-sozdat-pervoe-prilozhenie.html
   Шаблонизатор Blade
      https://laravel.su/docs/8.x/blade#the-at-verbatim-directive
   HTML-шаблоны
      https://laravel.su/docs/8.x/views
   База данных · Миграции
      https://laravel.su/docs/8.x/migrations#column-method-id
      https://laravel.su/docs/8.x/seeding
   Построитель запросов к база данных  
      https://laravel.su/docs/8.x/queries
      https://laravel.ru/docs/v5/queries   
   Eloquent ORM
      https://laravel.ru/docs/v5/eloquent
   Хранение - файловая Система 
      https://laravel.su/docs/6.x/filesystem#introduction

Смежные области:
   ООП в PHP -- в отдельном файле
   MySQL
   Терминал 
   Упровление зависимостями
      Composer
         Описание
            это менеджер зависимостей для PHP
               т.е. менеджер для подключения и управления сторонними библиотеками или пакетами в PHP-проекте
               без PHP использование composer не имеет смысла
               только консольный
         Основные задачи:
            автоматизация рутинных операций при установке PHP
               настройки
               автозагрузку компонентов
               обновление библиотек
                  при чём
                     одна библиотека может требовать для своей работы другую, другая третью и.т.д.
                        В итоге, может получаться ряд зависимостей, которые вы должны подключать.
               перенос проекта на рабочий сервер при большом объеме библиотек
               и.т.д.
            для решения этих проблем:
               в composer есть файл настроек composer.json
                  в котором прописывается всё необходемое 
                  Composer автоматически приходит в указанное состояние
         Установка
            глобально
               скачать и установить Composer 
               поместите путь к папке ~ / .composer / vendor / bin в переменную среды PATH
                  Система -> Дополнительные параметры системы -> Дополнительно -> Переменные среды -> переменная path
                  перезапустить комп
               добавить в переменную окружения path путь к composer.bat
               дополнительно можно добавить в path \Users\%userName%\AppData\Roaming\Composer\vendor\bin\ 
            локально
               Т.к. программа глобально не установлена, нужен загрузочный файл(мини-программа composer)
               для его загрузки пишем команду:
                  php -r «readfile('https://getcomposer.org/installer');» | php
               теперь в директории проекта появился файл composer.phar
               Всё, можно использовать.
                  php composer.phar require [название пакета]
            Отличия глобальной и локальной установки
               Команды запускаются по разному при локальной и глобальной установках:
                  Например:
                     Локально: php composer.phar require silex/silex ~1.1
                     Глобально: composer require silex/silex ~1.1
               При локальной установке нужно каждый раз скачивать установочный файл в папку текущего проекта
                  php -r «readfile('https://getcomposer.org/installer');» | php
               При глобальной установке этот файл не нужен. Composer запускается при любой текущей директории.
         Команды
            install — установка пакетов, прописанных в composer.json
            update – обновление пакетов
            dumpautoload — пересборка автозагрузчика
            require somepackage/somepackage:someversion — добавление нового пакета (по умолчанию пакеты ставятся из оф. репозитория). При установке пакет прописывается в composer.json
            update --lock — обновление файла блокировки composer.lock
            config --global cache-files-maxsize «2048MiB» — пример изменения параметра конфигурации
            --profile — добавление этого параметра к любой команде включит показ времени выполнения и объёма использованной памяти
            --verbose — подробная инфомация о выполняемой операции
            show --installed — список установленных пакетов с описанием каждого
            show --platform — сведения о PHP
            --dry-run — репетиция выполнения команды. Может добавляться к командам install и update. Эмулирует выполнение команды без её непосредственного выполнения. Необходим для того, чтобы проверить пройдёт ли установка пакетов и зависимостей успешно.
            remove — удаление пакета. Точная противоположность require
         Синтаксис composer.json

----------------------- ТЕОРИЯ start -----------------------  

   Laravel это 
      бесплатный PHP-фреймворк
      на основе архитектурной модели Model View Controller (MVC).
         Model-View-Controller (MVC, «Модель-Представление-Контроллер» или «Модель-Вид-Контроллер»)
            схема разделения данных приложения и управляющей логики 
            на три отдельных компонента 
               таким образом, что модификация каждого компонента 
               может осуществляться независимо
               модель (Model)
                  предоставляет данные и методы работы с ними: запросы в базу данных, проверка на корректность. 
                  реагирует на команды контроллера, изменяя своё состояние
                  не зависит от представления
               представление (View)
                  отвечает 
                     за отображение данных модели пользователю, 
                     не обрабатывает введённые данные пользователя
                     реагируя на изменения модели
               контроллер (Controller)
                  обеспечивает «связь» между пользователем и системой
                     контролирует и направляет данные от пользователя к системе и наоборот
                     т.е. интерпретирует действия пользователя, оповещая модель о необходимости изменений
            Назначение
               Основная цель этой концепции:
                  отделение бизнес-логики (модели) от её визуализации (представления, вида)
                  за счёт такого разделения повышается возможность повторного использования кода
               Наиболее полезно применение данной концепции в тех случаях, 
                  когда пользователь должен видеть одни и те же данные одновременно 
                     в различных контекстах 
                     и/или с различных точек зрения
                  к одной модели можно присоединить несколько видов
                     при этом не затрагивая реализацию модели
                        Пример
                           данные могут быть представлены одновременно  в виде 
                              электронной таблицы
                              гистограммы 
                              круговой диаграммы
                           не затрагивая реализацию видов, можно изменить 
                              реакции на действия пользователя 
                                 для этого достаточно использовать другой контроллер                        
                           разработчики специализируется только в одной из областей: 
                              разрабатывают графический интерфейс
                              разрабатывают бизнес-логику (модели)
   Представления – шаблоны Blade     подробнее см в отдельном файле
      Представления - это интерфейс Laravel- приложения
         который разделяет логику приложения и логику представления
      Представления хранятся в папке resources/views. 
      Laravel включает в себя довольно удобный макет, который содержит панель навигации под названием app.blade.php, 
         расположенную в папке Views / layouts. 
      С помощью механизма Blade в Laravel вы cможете 
         разделить свои страницы на подсекции, 
         использовать раздел панели навигации по умолчанию в новых представлениях.
      Пример
         в папке / resources / views 
            создайте файлы add.blade.php и edit.blade.php 
            с разметкой, приведенной ниже.
               <x-app-layout>
                  <x-slot name="header">
                     <h2 class="font-semibold text-xl text-gray-800 leading-tight">
                           //здесь должен быть header вашей страницы
                     </h2>
                  </x-slot>
                  //здесь должно быть содержимое тэга body
               </x-app-layout>
            В файле dashboard.blade.php также замените весь код на тот, 
            который приведен выше. 
   Доступ браузера к папкам
      по умалчанию у браузера доступ есть только к папке 'public'
   Миграции
      описание 
         миграция это функция, по сути обычные классы, 
            описывающие действия по созданию или изменению 
            АРХИТЕКТУРЫ базы данных данной версии
         миграция НЕ отвечают за данные в таблицах      
         это набор функций для контроля версии базы данных приложения при их использовании разными програмистами
            используются, чтобы создавать, изменять, а также делиться схемой(!!!) базы данных приложения
            используются с конструктором схем Laravel, чтобы упростить создание схемы базы данных. 
         пример
            выполнить команду 
               php artisan make:migration create_tasks_table --create=tasks
            найти только что созданную миграцию в папке /database/migrations
            создания схемы базы данны
               public function up()
                  {
                     Schema::create('tasks', function (Blueprint $table) {
                     $table->bigIncrements('id');
                     $table->string('description');
                     $table->integer('user_id')->unsigned()->index();
                     $table->timestamps();
                     });
                  }
            Команда migrate обновит изменения, внесенные в схему, в базе данных.
               php artisan migrate
      преимущества 
         легко перестроить структуру базы данных, используя файлы миграции в любой системе
      состоит из
         метод создания или изменения 
            конструктор структур
               класс Schema::
         метод отката
            конструктор структур
               класс Schema::         
         оба метода разрабатываются паралельно!!!
      в базе данных есть специальная таблиц которая хранит историю изменения базы данных
         в ней хранится название файла миграции и на каком цыкле выполнялась
   Модели 
      ЭТО основа web приложения в ней прописывается логика работы приложения
         (контроллеры и маршруты), так же как и виды (представления данных — например, в HTML) — всего лишь средство 
            для пользователя взаимодействовать с вашими моделями. 
      Примеры функциональности, которая может осуществляться моделью:
         Работа с базами данных
            установить отношения между таблицами
            запросы к БД
         Файловый ввод/вывод;
         Взаимодействие с вёб-сервисами.
      Для работы с кождой таблицей создаётся отдельная модель
         Пример
            Предположим, что вы пишите блог. 
            Вам наверняка потребуется модель «Сообщение». 
            Посетители могут комментировать ваши заметки, поэтому вам также понадобится модель «Комментарий». 
            А если пользователи будут комментировать, значит нам нужна будет модель «Пользователь». Уловили?
      Для обеспечения функциональности каждой модели создаётся экземпляр класса Model
         (наследуют класс Illuminate\Database\Eloquent\Model)
         методы которого описывают действия по созданию или изменению записей в базе данных
      НЕ отвечает за архетектуру БД
      Создать модель
         Эта команда создаст файл модели в папке приложения
            php artisan make:model name_model
         Эта команда создаст файл модели в папке приложения а также миграцию БД 
            php artisan make:model name_model --migration
               или
            php artisan make:model name_model -m
         Пример 
            Модель задачи (файл task.php находится в app/task.php):
               ...
               use App\Models\User;
               class Task extends Model
               {    
                  public function user()
                  {
                     return $this->belongsTo(User::class);
                  }
               }
            Модель пользователя (файл user.php находится в app/user.php):
               ...
               use App\Models\Task;
               class User extends Authenticatable
               {
                  ...
                  public function tasks()
                  {
                     return $this->hasMany(Task::class);
                  }
               }
      Именование таблиц
         Имя таблицы к которой будет привязана модель 
            устанавливается 
               по умолчанию свойством table в классе модели
               указывается явно  параметре  .................
            будет использовано имя класса в нижнем регистре и во множественном числе
               пример
                  модель Flight хранит свои данные в таблице flights
                  <?php
                  namespace App;
                  use Illuminate\Database\Eloquent\Model;
                  class Flight extends Model
                  {
                  /**
                     * Связанная с моделью таблица.
                     *
                     * @var string
                     */
                  protected $table = 'my_flights';
                  }
      Eloquent это  раздел фреймворка Laravel предназначенный для работы с записями 
   Первичные ключи
      по умолчанию предполагается, что каждая таблица 
         имеет первичный ключ с именем id который является инкрементным числом и автоматически приведёт его к типу int
      ??пределить первичный ключ 
         в классе модели:
            protected $primaryKey = 'MyprimaryKey';
      Если вы хотите использовать неинкрементный или нечисловой первичный ключ
         задайте открытому свойству $incrementing вашей модели значение false
         
            
            

   
   Интерфейс командной строки Artisan
      содержит различные команды:
         Tinker позволяет взаимодействовать со всем вашим Laravel - приложением 
            через окно консоли без необходимости доступа к веб-интерфейсу. 
            Основным преимуществом Tinker является то, что вы можете 
               тестировать отношения, 
               отлаживать данные и 
               получать доступ к 
                  Eloquent ORM, 
                  задачам, 
                  тестам, 
                  событиям 
                  и т. д. 
            Пример
               вы зарегистрировались в приложении и создали две задачи. 
               Теперь вы проверяете эти задачи прямо в окне консоли:
                  $ php artisan tinker
                  >App\User::first()->tasks;
               Tinker напрямую обращается к базе данных
   Контроллеры
      Контроллеры используются для распределения трафика между представлениями и моделями. 
         Они могут сгруппировать несколько логических схем обработки запросов в один класс. 
         Таким образом, как правило, они получают весь запрос и, исходя из своей логики, 
         перенаправляют или возвращают соответствующие данные. 
      Создать контроллер
         php artisan make:controller TasksController
         будет создан TasksController, 
         который вы сможете найти в папке app / Http / Controllers
   Маршрутизация
      Маршрут это обычная ссылка на страницу сайта точнее часть её после доменного имени
      Маршрутизация означает принятие запроса и его перенаправление к соответствующей функции. 
      Все маршруты Laravel должны быть определены в файлах маршрутов, находящихся в вашем каталоге routes
         Например
            настройка маршрутизации для API будет находиться в файле «/routes/api.php»
            настройка маршрутизации для нашего веб-приложения будет находиться в «/routes/web.php».      
      Файл routes/web.php определяет маршруты для вашего веб-интерфейса
         Этим маршрутам назначается группа посредников web, которая обеспечивает такие функции, как состояние сессии и защита от CSRF.
      К маршрутам, определенным в routes/web.php, можно получить доступ, 
         введя URL-адрес определенного маршрута в вашем браузере
      Доступные методы маршрутизатора
         Route::get($uri, $callback);
         Route::post($uri, $callback);
         Route::put($uri, $callback);
         Route::patch($uri, $callback);
         Route::delete($uri, $callback);
         Route::options($uri, $callback);
      Примеры стандартных маршрутов
         Авторизоваться;
         Зарегистрироваться;
         Показать список всех наших задач;
         Добавить новые задачи;
         Удалить существующие задачи.
      Laravel Jetstream добавляет вход и регистрацию, 
         поэтому теперь нам нужно позаботиться только о трех маршрутах.
   Привязка модели к маршруту (Route-Model Binding)
      Это механизм для внедрения экземпляра модели в маршруты. 
      Это значит что 
         вы можете передавать объект модели 
            в маршруты
            в представления по маршрутам
      Эта функция поможет вам легко получить значения объекта в представлении
   Структура папок проэкта 
      App: эта папка является ядром приложения и содержит основной код
         Console: эта папка содержит все пользовательские команды Artisan, созданные с помощью make: command
         Exceptions: эта папка содержит обработчик исключений приложения. 
            место для добавления пользовательских классов исключений
         Http: этот каталог содержит 
            контроллеры
            промежуточное программное обеспечение
            запросы
         Models: для хранения файлов моделей. 
            Раньше модели хранились в папке App, 
            но теперь их можно хранить и в папках App / Models.
         Providers: эта папка содержит всех поставщиков услуг для вашего приложения ?????
      Bootstrap: эта папка содержит загрузочную программу фреймворка и файлы конфигурации
         Она также содержит папку с файлами кеша, сгенерированными фреймворком.
      Config: эта папка содержит все файлы конфигурации вашего приложения.
      Database: эта папка содержит все миграции и начальные данные базы данных. 
         Вы также можете хранить здесь файлы базы данных SQLite.
      Public: папка содержит всё необходимое для отображения ГОТОВЫХ страниц 
         пользователю после компиляции т.е. Production 
      Resources: папка содержит всё необходимое для отображения страниц 
         пользователю при разработке т.е. Development 
         CSS   пака стилей
         LESS
         SASS
         views папка шаблонов страниц
         папка lang для хранения языковых файлов
      Routes: эта папка содержит все маршруты приложения
         а файл php получает все запросы к вашему приложению
         и здесь вы можете перенаправить запросы на соответствующие методы контроллера.
      Storage: эта папка содержит 
         шаблоны Blade
         файлы сеансов
         файлы кеша
         и другие
      Tests: эта папка содержит все тестовые файлы.
      Vendor: эта папка содержит все Composer-зависимости и не только
         .env - конфигурация проэкта 
            т.е.
               установлены все переменные которые будут переданы в папку config
   Базы данных
      Конфигурация служб баз данных Laravel находится в конфигурационном файле config/database.php вашего приложения. 
      В этом файле вы можете определить все соединения к базе данных
         а также указать, какое соединение должно использоваться по умолчанию. 
      Большинство параметров конфигурации в этом файле определяется значениями переменных окружения вашего приложения. 
      В этом файле представлены примеры для большинства систем баз данных, поддерживаемых Laravel.
      Конфигурация SQLite
         настроить переменные окружения так, чтобы они указывали на эту базу данных
            указать абсолютный путь к базе данных в переменной DB_DATABASE окружения:
               DB_CONNECTION=sqlite
               DB_DATABASE=/absolute/path/to/database.sqlite
         чтобы включить ограничения внешнего ключа для соединений SQLite
            установите переменную DB_FOREIGN_KEYS окружения в true:
               DB_FOREIGN_KEYS=true
         Возможно использовать разные соединения с базой данных для разных операторов таких как SELECT INSERT UPDATE DELETE
            Laravel всегда будут использоваться соответствующие соединения, 
               независимо от того, используете ли вы сырые запросы построителя запросов или Eloquent ORM.
                  пример:
                     настройки соединения для чтения / записи 
                        'mysql' => [
                           'read' => [
                              'host' => [
                                    '192.168.1.1',
                                    '196.168.1.2',
                              ],
                           ],
                           'write' => [
                              'host' => [
                                    '196.168.1.3',
                              ],
                           ],
                           'sticky' => true,
                           'driver' => 'mysql',
                           'database' => 'database',
                           'username' => 'root',
                           'password' => '',
                           'charset' => 'utf8mb4',
                           'collation' => 'utf8mb4_unicode_ci',
                           'prefix' => '',
                        ],
                     Обратите внимание
                        в массив конфигурации были добавлены три ключа: read, write и sticky. 
                        Ключи read и write имеют значения массива, содержащие один ключ: host. 
                        Остальные параметры базы данных для соединений read и write будут объединены из основного массива конфигурации mysql.
            В массивы read и write вам нужно помещать только те элементы, 
               значения которых вы хотите переопределить из основного массива mysql. 
               в примере 
                  192.168.1.1 будет использоваться в качестве хоста для соединения «чтение», 
                  192.168.1.3 – для соединения «запись». 
                  учетные данные БД, префикс, набор символов и все другие параметры из основного массива mysql 
                     будут совместно использоваться обоими соединениями
            Если в массиве конфигурации host существует несколько значений, 
               то для каждого запроса хост базы данных будет выбран случайным образом.
   Наполнение БД
      при наполнении базы данных автоматически отключается защита массового присвоения
      классы наполнители
         seeder -- сеятель, наполнитель
         классы наполнителей хранятся в каталоге database/seeders
         класс DatabaseSeeder уже определен по умолчанию
         класс наполнителя по умолчанию содержит только один метод: run
            который вызывается при выполнении команды db:seed Artisan
            в методе run можно
               как угодно вставлять данные в свою базу данных, 
               использовать построитель запросов для самостоятельной вставки данных 
               использовать фабрики моделей Eloquent
               объявить любые необходимые типы зависимостей
                  они будут автоматически извлечены и внедрены через контейнер служб Laravel.
            пример
               class DatabaseSeeder extends Seeder
               {
                  /**
                  * Запустить наполнение базы данных.
                  * @return void
                  */
                  public function run()
                  {
                     DB::table('users')->insert([
                           'name' => Str::random(10),
                           'email' => Str::random(10).'@gmail.com',
                           'password' => Hash::make('password'),
                     ]);
                  }
               }
         метод call класса DatabaseSeeder для запуска любых наполнителей
      фабрики моделей
         генерируют случайные данные для тестовых заполнений БД
         это классы, которые 
            расширяют базовый класс фабрики Laravel 
            определяют метод definition который возвращает набор значений атрибутов по умолчанию
               которые должны применяться при создании модели с использованием фабрики
            через свойство $faker фабрики получают доступ к библиотеке Faker PHP
               которая позволяет вам удобно генерировать различные виды случайных данных для тестирования
   Построитель запросов к база данных
      метод table
      метод get
      метод first
      метод find
      метод insert
         принимает 
            массив имен и значений столбцов  --  одна запись
               DB::table('users')->insert([
                  'email' => 'kayla@example.com',
                  'votes' => 0
               ]);
            массив массивов  --  несколько записей
               DB::table('users')->insert([
                  ['email' => 'picard@example.com', 'votes' => 0],
                  ['email' => 'janeway@example.com', 'votes' => 0],
               ]);
      метод insertOrIgnore
         будет игнорировать ошибки повторяющихся записей при вставке записей в базу данных:
   Отношения




----------------------- ТЕОРИЯ end -----------------------  


----------------------- Практика start -----------------------  
   Общий алгоритм работы сайта
      по базам данных
         создать
            БД
            таблицы в БД
               миграции
         установить отношения между таблицами
            модели
         выполнять операции с записями в БД
            модели
      по представлениям
   Установка
      установливается на веб-сервер
      выполнить следующую команду
         composer global require “laravel/installer”
   Создать проект 
      перейти в нужную папку
      выполнить команду 
         laravel new projectname
         composer create-project --prefer-dist laravel/laravel laravelblog   // эта команда не проверялась
      настроить базу донных подробнее см. ниже
         SQLite предустановлена в Laravel
         любые другие:
            предворительно установить в системе
         Laravel позволяет файлу config/database.php настраивать базу данных, 
            но лучше не хранить в нем учетные данные. 
         файл .env
            который по умолчанию находится в корневой папке Laravel
            в нём можно хранить различные типы учетных и других данных.
      создать аутентификацию
         Laravel Jetstream
            это скелет» для аутентификации
               всё, связанное с аутентификацией: вход пользователя, регистрация, потеря пароля, двухфакторная аутентификация и т.д. 
               будет создаваться заранее, если вам это необходимо.  
            при создании проэкта:
               laravel new todo --jet
            добавить в существующий проэкт:
               установить пакет Jetstream
                  composer require laravel/jetstream
               выбрать стек: Liveware или Inerta ???????
                  для livewire
                     php artisan jetstream:install livewire
               запустите 
                  «npm install && npm run dev»
   Запуск проекта на Localhost
      перейти в корень вашего приложения в терминале
      запустите в окне терминала команду 
         php artisan serve 
      авто перезапуск страницы
         npm run watch
   Маршруты
      отображение стартовой страницы по умолчанию
         Route::get('/', function () {
               return view('welcome');
            });
      метод view('name_template');
         ссылается на файл шаблона из папки resources\views
         расширение .blade.php при этом можно упустить
      отображение произвольной страницы "hello"
            Route::get('hello', function () {
               return 'hello';
            });
   Модели
      создать файл модели  
         php artisan make:model имя модели -m
            ключ -m  создаст вместе с файлом модели файл миграции 
         запустить файлы моделей на исполнение
   Миграции
         запустить файлы миграций на исполнение
            php artisan migrate  // все(!) миграции в папке database\migrations 
         откат всех миграций  
            php artisan migrate:reset
   Базы данных
      вариант_1
         создать базу данных MySQL
            создать новую базу данных SQLite, 
               touch database/database.sqlite 
         подключить эту базу данных к приложению Laravel
      вариант_2
         создать БД в phpMyadmin
            установить кодировку
            подключить БД к loravel
               в файле .env
                  DB_CONNECTION=mysql
                  DB_HOST=127.0.0.1 (в настройках phpMyadmin)
                  DB_PORT=3306 (в настройках phpMyadmin)
                  DB_DATABASE=имя созданной базы данных
                  DB_USERNAME=root (или установленное в при создании БД в phpMyadmin)
                  DB_PASSWORD=root (или установленное в при создании БД в phpMyadmin)
      Выполнение SQL-запросов
         настроив соединение с базой данных можно выполнять запросы, используя фасад DB. 
         Фасад DB содержит методы для каждого типа запроса: select, update, insert, delete, и statement.
            Пример  
               <?php
                  namespace App\Http\Controllers;
                  use App\Http\Controllers\Controller;
                  use Illuminate\Support\Facades\DB;
                  class UserController extends Controller
                  {
                     /**
                     * Показать список всех пользователей приложения.
                     *
                     * @return \Illuminate\Http\Response
                     */
                     public function index()
                     {
                        $users = DB::select('select * from users where active = ?', [1]);

                        return view('user.index', ['users' => $users]);
                     }
                  }
                  первым аргументом, переданным методу select, является SQL-запрос, а 
                  вторым аргументом – любые привязки параметров, необходимые для запроса. 
         Метод select всегда возвращает «массив» результатов. 
         Каждый результат в массиве будет объектом stdClass PHP, 
            представляющим запись из базы данных:
               use Illuminate\Support\Facades\DB;
               $users = DB::select('select * from users');
               foreach ($users as $user) {
                  echo $user->name;
               }
      Проверить подключение к БД
         if(DB::connection()->getDatabaseName())
         {
            echo "Yes! successfully connected to the DB: " . DB::connection()->getDatabaseName();

         }
   Наполнение БД

      Реальными данными

      Фейковыми данными
         алгоритм
            создать
               фабрику для канкретной модели
                  прописать заполняемые появиля и чем заполнять
               пример
                  class UserFactory extends Factory{
                     protected $model = User::class;
                     pablic function definition(){

                        return[
                           'name' => $this -> faker -> name
                        ];
                     }
                  }
               сидр
                  для уже созданной модели вызвать 
                     фабрику 
                     метод create() который добавит запись в БД 
                  пример 
                     class DatabaseSeeder extend Seeder{
                        public function run(){
                           User::factory(/*parameters*/)->create();
                        }
                     }
               модель



      сгенерировать новый наполнитель:
         php artisan make:seeder name_Seeder
      php db:seed по умолчанию запускает класс Database\Seeders\DatabaseSeeder, 
         который, в свою очередь, может вызывать другие классы
      php artisan db:seed --class=UserSeeder
         запуск конкретного класса наполнителя
----------------------- Практика end -----------------------  


----------------------- Проблемы -- решения start -----------------------
   Проблема
      внезапно в рабочем проэкте:
         при запуске artisan serve
            Failed to open stream: No such file or directory ......
         и при запусеке npm run watch
            "mix" не является внутренней или внешней командой, исполняемой программой или пакетным файлом.
   Решение
      по artisan serve
         переустановка laravel
            composer update --no-scripts  --запускается но сервер не работает
         т.к. laravel переустанавливался после создания проэкта то файл .env небыл создан
            copy .env.example .env       // копировать .env.example как .env
            php artisan key:generate   // устанавливает значение APP_KEY в вашем файле .env. 
                                       // По умолчанию эта команда запускается после команды composer create-project laravel/laravel
      по npm run watch
         переустановил laravel-mix
            npm install laravel-mix --save-dev
         laravel-mix -- запускается но сервер не работает


----------------------- Проблемы -- решения end -----------------------
php artisan db:seed --class=DatabaseSeeder_all_lists
php artisan migrate:reset
php artisan migrate




----------------------- ЧЕРНОВИК -----------------------

