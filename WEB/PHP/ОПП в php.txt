Нужно знать:
   $thise
      контекст данного экземпляра класса
   Гетеры
   Сетеры




Объекты в PHP есть не что иное как переменные абстрактного типа данных (который задаёт программист). 
Класс -- каркас,шаблон, чертёж сущьности
   class Human{
      pablic $name;  // значение по умолчанию не задано -- автоматически устанавливается в NULL
      pablic $surname;   // значение по умолчанию не задано -- автоматически устанавливается в NULL
      pablic $age = 12; // значение по умолчанию задано
   }
Объект -- экземпляр класса -- сущьность созданная из класса фактически отдельный вид данных
   $c_1 = new Human();
   $c_2 = new Human();
   $c_3 = new Human();
   и всё это разные сущьности!! т.е. занимают разные ячейки памяти
Метод -- функция класса т.е. внутри класса
   создать метод
      class Human{
         pablic $name;
         pablic $surname;
         pablic $age;

         pablic function Name($name){
            return 'Hello ' . $name;
         }
      } 
   вызвать метод 
      $c_2 = new Human();
      echo $c_2 -> Name('Vasy');
Области видимости
   pablic
      видимо внутри и с наружи класса
   rivate
      видимо только внутри класса
   protected
      видимо внутри класса а так же внутри классов наследников
Свойства -- характеристика, данные объекта
   создать свойство   
      class Human{
         pablic $name;
         pablic $surname;
         pablic $age;
      } 
   изменить / получить свойство
      обращаясь на прямую к свойвтву:
         $c_1 = new Human; 
         записать свойство
            $c_1 -> name = 'Alex';
            $c_1 -> surname = 'Petrov';
            $c_1 -> age = 32;
         прочитать свойство
            echo $c_1 -> name;
            echo $c_1 -> surname;
            echo $c_1 -> age; 
         будем обращаться сразу ко всем экземплярам класса 
            т.к.
               классы передают данные всегда по ссылке
               подробнее см. "Передача данных"
      для того что бы менять / получать свойства только в одном экземпляре класса 
      в классе прописывают для каждого свойства специальные методы, ф-ции, setName() getName()
         class Human(){
            private $name;
            private $surname;
            private $age;

            pablic function setName($name){
               // ... возможные проверки
               $this->name = $name;
            }
            pablic function setSurname($surname){
               // ... возможные проверки
               $this->surname = $surname;
            }

            pablic function getName(){
               //... что то
               return $this->name;
            }
            pablic function getSurname(){
               //... что то
               return $this->surname;
            }
         }
      нужно использовать магические методы __set() и __get()
      подробнее см. раздел "магические методы"
Магические методы это
   специальные методы, которые переопределяют действие PHP по умолчанию, когда над объектом выполняются определённые действия
   имена этих методов начинаются с __ 
   !!! Внимание:
      __construct() и __destruct() не должны объявлять возвращаемый тип; в противном случае выдаётся фатальная ошибка
      Если объявления типа используются в определении магического метода,  (???????)
         они должны быть идентичны сигнатуре, описанной в этом документе. 
         В противном случае выдаётся фатальная ошибка
   могут быть private
      __construct()
         это обычные методы, которые вызываются первыми(?!) при создании экземпляра класса
            могут иметь произвольное количество аргументов которые 
               могут быть обязательными, 
               могут быть типизированными, 
               могут иметь значения по умолчанию 
         аргументы конструктора указываются в круглых скобках после имени класса.
         применяется, например, для
            инициализации какого-либо состояния объекта перед его использованием
         замечания: 
            до PHP 8.0.0 вместо синтаксиса __construct() использовался метод одноимённый с классом.
               До PHP 8.0.0, классы в глобальном пространстве имён будут интерпретировать метод, 
                  названный ТАК ЖЕ, как класс, как КОНСТРУКТОР созданный в старом стиле
                     Этот синтаксис считается устаревшим и будет вызывать ошибку уровня E_DEPRECATED, 
                        но всё равно эти методы будут вызываться в качестве конструктора. 
                  если в классе присутствуют и __construct(), и метод с именем класса, то 
                     в качестве конструктора будет вызван __construct().
               Для классов 
                  находящихся в собственном пространстве имён 
                  и для всех классов, начиная с PHP 8.0.0, 
                  метод, названный по имени класса, будет игнорироваться.
                  В новом коде всегда используйте __construct().
            конструкторы, определённые в классах-родителях, не вызываются автоматически, 
                  если дочерний класс определяет собственный конструктор. 
               Чтобы вызвать конструктор, объявленный в родительском классе, требуется 
                  вызвать parent::__construct() внутри конструктора дочернего класса. 
               Если в дочернем классе не определён конструктор, то 
                  он может быть унаследован от родительского класса как обычный метод (если он не был определён как приватный)
            освобождается от обычных правил совместимости сигнатуры при наследовании см. далее
            если у класса нет конструктора, или 
               его конструктор не имеет обязательных параметров, 
               скобки после имени класса можно не писать.

         пример
            <?php
               class Point {
                  protected int $x;
                  protected int $y;

                  public function __construct(int $x, int $y = 0) {
                     $this->x = $x;
                     $this->y = $y;
                  }
               }

               // Передаём оба параметра.
               $p1 = new Point(4, 5);
               // Передаём только обязательные параметры. Для $y используется значеие по умолчанию 0.
               $p2 = new Point(4);
               // Вызываем с именованными параметрами (начиная с PHP 8.0):
               $p3 = new Point(y: 5, x: 4);
            ?>
      __destruct()
      __clone()
   должны быть pablic
      __call()
      __callStatic()
      __get()
         PHP автоматически вызовет этот метод
         при попытке получить или обратиться к свойству которое не было объявлено или не видно в текущей области видимости
      __set()
      __isset()
      __unset()
      __sleep()
      __wakeup()
      __serialize()
      __unserialize()
      __toString()
      __invoke()
      __set_state()
      __debugInfo()
Перегрузка это
   возможность создавать свойства и методы 
         которые не были объявлены или 
         не видны в текущей области видимости 
      в уже созданных классах
   обрабатываются с помощью магических методов
      есле таковые были изначально объявленны в классе
   все методы перегрузки должны быть объявлены как public
   Замечания:
      Ни один из аргументов этих магических методов не может быть передан по ссылке.
      Интерпретация перегрузки в PHP отличается от большинства объектно-ориентированных языков
         Традиционно перегрузка означает 
            возможность иметь несколько одноимённых методов с разным количеством и типами аргументов.
   Примеры
      public __set(string $name, mixed $value): void
      public __get(string $name): mixed
      Метод __set() будет выполнен при записи данных в недоступные (защищённые или приватные) или несуществующие свойства.
      Метод __get() будет выполнен при чтении данных из недоступных (защищённых или приватных) или несуществующих свойств.

Операции с объектами
   Передача данных
      по значению
         $a = 1;
         $b = 2;
         $c = $a + $b;
         echo $c;  // 3
      по ссылке
         $a = 1;
         $b = &a; // ссылка на ячейку памяти которую занимает переменная $а
                  // т.е. всё что попадает в переменную $b попадает в ячейку памяти переменной $а
         $b = 4;
         $c = $a + $b;
         echo $c;  // 8
      классы всегда по ссылке!!!
         $a = new Human;
         $b = $a; // второй класс не создан!!  передача по ссылке!!!!
   Сравнение объектов
      $a_1 = new Human;
      $a_2 = new Human;
      $a_1 == $a_2 // не строгое сравнение   сравниваются только свойства   в результате TRUE
      $a_1 === $a_2 // строгое сравнение в результате FALSE т.к. у разных экземпляров класса разные внутрение идентификаторы






Правила совместимости сигнатуры
   При переопределении метода его сигнатура должна быть совместима с родительским методом
      в противном случае выдаётся фатальная ошибка или, до PHP 8.0.0, генерируется ошибка уровня E_WARNING. 
   сигнатура является совместимой, если 
      она соответствует правилам контравариантности, делает обязательный параметр необязательным 
      и если какие-либо новые параметры являются необязательными. 
      Это известно как принцип подстановки Барбары Лисков или сокращённо LSP. 
      Правила совместимости не распространяются на конструктор и сигнатуру private методов, 
      они не будут выдавать фатальную ошибку в случае несоответствия сигнатуры.
      Ковариантность и контравариантность
         https://www.php.net/manual/ru/language.oop5.variance.php

